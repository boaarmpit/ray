<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1416237983054">{:repl-history {:ide [], :local [&quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) (m/inverse M) 0))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) (m/inverse M) 0))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) \n          (let [M-inv (m/inverse M)]))\n        M-inv        \n        )))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            M-inv (if-not (zero? det) (m/inverse M) 0)]\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            M-inv (if-not (zero? det) (m/inverse M) 0)]\n        1)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) (m/inverse M) 0))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) 1 0)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) (m/inverse M) 0)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) 1)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (m/inverse M)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) (m/inverse M))]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            M-inv (m/inverse M)\n            ]\n        (if-not (zero? det) (m/inverse M) 0)\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            ;det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            M-inv (m/inverse M)]\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            ;det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            M-inv (m/inverse M)\n            b (*M-inv (- P0 plane-point))\n            ]\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            ;det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            M-inv (m/inverse M)\n            b (* M-inv (- P0 plane-point))\n            ]\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            ;det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            M-inv (m/inverse M)\n            b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;M-inv (m/inverse M)\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [tmp 1])))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;M-inv (m/inverse M)\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [tmp 1]\n            tmp\n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)]\n            M-inv\n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (* M-inv (- P0 plane-point))]\n            M-inv\n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (* M-inv (- P0 plane-point))]\n            M-inv\n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                ;b (* M-inv (- P0 plane-point))\n                ]\n            M-inv\n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                ;b (* M-inv (- P0 plane-point))\n                ]\n            P0\n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                ;b (* M-inv (- P0 plane-point))\n                ]\n            plane-point\n            \n            )))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                ;b (* M-inv (- P0 plane-point))\n                ]\n            plane-point\n            )))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (* M-inv (- P0 plane-point))\n                ]\n            b)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                tmp (- P0 plane-point)\n                b (* M-inv (- P0 plane-point))\n                ]\n            b)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (* M-inv (- P0 plane-point))\n                ]\n            b)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                tmp (- P0 plane-point)\n                b (* M-inv (- P0 plane-point))\n                ]\n            tmp)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                tmp (- P0 plane-point)\n                b (* M-inv (- P0 plane-point))\n                ]\n            M-inv)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                tmp (- P0 plane-point)\n                b (mmul M-inv (- P0 plane-point))\n                ]\n            M-inv)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                ]\n            b)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (nth b 0)\n                ]\n            b)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                ]\n            b)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                ]\n            u-coord)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (- (v/get b 2))\n                ]\n            u-coord)))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (- (v/get b 2))\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         ;(intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (- (v/get b 2))\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (- (v/get b 2))\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (- 0 (v/get b 2))\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (- (v/get b 2))\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 1])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -2 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 0 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (if-not (zero? det)\n          (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1)\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\&quot;)\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M ^Amatrix (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M  (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(def mat (array [[1 2 3] [4 5 6] [7 8 9]]))&quot; &quot;mat&quot; &quot;(m/transpose mat)&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M (m/transpose (array [u-axis v-axis (- P1)]))\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M  (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            ;M-inv (if-not (zero? det) (m/inverse M))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M-trans (m/transpose M)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -2 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 0])\n                          :ray-direction (v/vec [1 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 0])\n                          :ray-direction (v/vec [2 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 0])\n                          :ray-direction (v/vec [2 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 2 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                              :u-axis (v/vec [1 0 0])\n                              :v-axis (v/vec [0 0 1])})\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:sphere-intersection closest-intersection)\n            (let [\n                  sphere-intersection (:sphere-intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n                \n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n  \n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product u-axis v-axis)}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! u-axis v-axis)}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection :normal normal :distance t\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal surface]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :intersection intersection :normal normal :distance t\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                      :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                      :phong-exponent 50})\n  \n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal surface]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :intersection intersection :normal normal :distance t\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  (def plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                         :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                         :phong-exponent 50}))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal surface]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        ;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                intersection (if (pos? t) (+ P0 (* t P1)))\n                distance (if (pos? t) t)\n\n                ]\n            {:scene-object this :intersection intersection :normal normal :distance distance\n             :u-coord      u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  (def plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                         :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                         :phong-exponent 50}))\n\n  (def my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                             :u-axis      (v/vec [1 0 0])\n                             :v-axis      (v/vec [0 0 1])\n                             :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface     plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 -0.5 0])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 0 1])\n                              :normal      (v/vec [0 1 0])          ;(v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 -0.5 0])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 0 1])\n                              :normal      (v/vec [0 1 0])          ;(v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 (math/sqrt 5.5)])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot; my-plane&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 (math/sqrt 5.5)])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans (array [u-axis v-axis (- P1)])\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          ;det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans (array) [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans (array [u-axis v-axis (- P1)])\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          ;det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              ;M (m/transpose M-trans)\n              ;M-inv (m/inverse M)\n              ;b (mmul M-inv (- P0 plane-point))\n              ;u-coord (v/get b 0)\n              ;v-coord (v/get b 1)\n              ;t (v/get b 2)\n              ;hit (pos? t)\n              ;intersection (if hit (+ P0 (* t P1)))\n              ;distance (if hit t)\n\n              u-coord 0\n              v-coord 0\n              intersection 0                                ;(v/vec3 [0 0 0])\n              distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det 1                                             ; (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              ;M (m/transpose M-trans)\n              ;M-inv (m/inverse M)\n              ;b (mmul M-inv (- P0 plane-point))\n              ;u-coord (v/get b 0)\n              ;v-coord (v/get b 1)\n              ;t (v/get b 2)\n              ;hit (pos? t)\n              ;intersection (if hit (+ P0 (* t P1)))\n              ;distance (if hit t)\n\n              u-coord 0\n              v-coord 0\n              intersection 0                                ;(v/vec3 [0 0 0])\n              distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(do\n\n\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  (def plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                         :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                         :phong-exponent 50}))\n\n  (def my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                             :u-axis      (v/vec [1 0 0])\n                             :v-axis      (v/vec [0 0 1])\n                             :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface     plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              ;M (m/transpose M-trans)\n              ;M-inv (m/inverse M)\n              ;b (mmul M-inv (- P0 plane-point))\n              ;u-coord (v/get b 0)\n              ;v-coord (v/get b 1)\n              ;t (v/get b 2)\n              ;hit (pos? t)\n              ;intersection (if hit (+ P0 (* t P1)))\n              ;distance (if hit t)\n\n              u-coord 0\n              v-coord 0\n              intersection 0                                ;(v/vec3 [0 0 0])\n              distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 (math/sqrt 5.5)])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  ;intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(time (image/show (render-spheres) :title \&quot;Isn't it beautiful?\&quot;))&quot;], :remote []}}</component>
</project>

