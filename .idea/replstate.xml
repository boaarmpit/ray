<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1415440717914">{:repl-history {:ide [], :local [&quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (array [0 0 1])\n        ^Vector3 camera-x (array [1 0 0])\n        ^Vector3 camera-y (array [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        ;(v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        ;(v/normalise! dir)&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        ;(v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        ;(v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ^double ix res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def ^int res-x 500)\n  (def ^int res-y 500))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def res-x 500)\n  (def res-y 500))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (int ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        width (int res-x)\n        height (int res-y)\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) width) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) height) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [;u-tex 1                                     ;(mget plane-intersection 0)\n                ;v-tex 1                                     ;(mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [u-tex (mget plane-intersection 0)\n                v-tex (mget plane-intersection 2)\n                ;pixel-intensity 1                           ;(checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [u-tex (mget plane-intersection 0)\n                v-tex (mget plane-intersection 2)\n                pixel-intensity (checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result 1.0 1.0 1.0 1.0                      ;^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [u-tex (mget plane-intersection 0)\n                v-tex (mget plane-intersection 2)\n                pixel-intensity (checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (if plane-intersection\n          (let [u-tex (mget plane-intersection 0)\n                v-tex (mget plane-intersection 2)\n                pixel-intensity (checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ;^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)])\n        (if plane-intersection\n          (let [u-tex (mget plane-intersection 0)\n                v-tex (mget plane-intersection 2)\n                pixel-intensity (checker-texture u-tex v-tex 1)\n                ]\n            (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                        )\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ;r-rand (rand)\n        ;g-rand (rand)\n        ;b-rand (rand)\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ;^Vector3 plane-intersection (v/vec3 [0 0 0])\n        pixel-intensity 1.0\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def res-x 1000)\n  (def res-y 1000))&quot; &quot;(defn render-old []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ ix res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ iy res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn display\n  \&quot;Displays an image in a new frame\&quot;\n  [^BufferedImage image\n   &amp; {:keys [title]}]\n  (mikera.gui.Frames/displayImage image (str (or title \&quot;Enlight Render\&quot;))))&quot; &quot;(time (image/show (render) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (display (render)))&quot; &quot;(time (render))&quot; &quot;(defn ray-plane \n  \&quot;Ray-(ground)Plane Intersection:\n  where the ray is defined as P0+tP1 with parameter t\n  and the plane is the x-z (ground) plane (y=0)\n  P0 and P1 are matrix.core vectorz arrays (vectors)\&quot;\n  [P0 P1]\n  (if-not (zero? (mget P1 1))\n    (let [t (- (/ (mget P0 1) (mget P1 1)))]\n      (if (pos? t)\n        (+ P0 (* P1 t))))))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-plane []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity (checker-texture u-tex v-tex 1)]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity 1]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity (checker-texture 1 1 1)]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity 1.0]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0\n                          )\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity (checker-texture 1 1 1)]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(checker-texture 1 1 1)&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity 0.0]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [^double pixel-intensity 1.0]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity (checker-texture 1 1 1)]\n              ;(.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setValues colour-result 1.0 1.0 1.0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity 1.0]\n              ;(.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setValues colour-result 1.0 1.0 1.0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity 1.0]\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setValues colour-result 1.0 1.0 1.0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [plane-intersection (ray-plane camera-location dir)]\n          (if plane-intersection\n            (let [pixel-intensity 1.0]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result 1.0 1.0 1.0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(time (image/show (render-plane) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at sphere-origin with radius sphere-radius\&quot;\n  [P0 P1 sphere-origin sphere-radius]\n  0\n  )&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [sphere-intersection (ray-sphere camera-location dir 0 0)]\n          (if sphere-intersection\n            (let [pixel-intensity 1.0]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result 1.0 1.0 1.0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [sphere-intersection (ray-sphere camera-location dir 0 0)]\n          (if sphere-intersection\n            (let [pixel-intensity 1.0]\n              ;(.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result 1.0 0 0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        ^double sphere-radius 1\n\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [sphere-intersection (ray-sphere camera-location dir 0 0)]\n          (if sphere-intersection\n            (let [pixel-intensity 1.0]\n              ;(.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result 1.0 0 0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n         sphere-radius 1\n\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [sphere-intersection (ray-sphere camera-location dir 0 0)]\n          (if sphere-intersection\n            (let [pixel-intensity 1.0]\n              ;(.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result 1.0 0 0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n         sphere-radius 1.0\n\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [sphere-intersection (ray-sphere camera-location dir 0 0)]\n          (if sphere-intersection\n            (let [pixel-intensity 1.0]\n              ;(.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result 1.0 0 0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (let [a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))]\n    0))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (let [a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))\n        c (- (v/dot (- P0 C) (- P0 C)) (* r r))]\n    0))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (let [a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))\n        c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n        det (- (* b b) (* 4 a c))]\n    0))&quot; &quot;(time (image/show (render-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (let [^double a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))\n        c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n        det (- (* b b) (* 4 a c))]\n    0))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (let [a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))\n        c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n        det (- (* b b) (* 4 a c))]\n    (if det 1 0)))&quot; &quot;(if 0)&quot; &quot;(if 0 0 1)&quot; &quot;(if false 0 1)&quot; &quot;(if false 1 0)&quot; &quot;(if 0 1 0)&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (let [a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))\n        c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n        det (- (* b b) (* 4 a c))]\n    (if det true false)))&quot; &quot;(defn ray-sphere\n  \&quot;Ray-Sphere Intersection:\n   The ray is defined as P0+tP1 with parameter t\n   The sphere is centered at C with radius r\&quot;\n  [P0 P1 C r]\n  (v/normalise! P0)\n  (v/normalise! P1)\n  (v/normalise! C)\n  (let [a (v/dot P1 P1)\n        b (* 2 (v/dot P1 (- P0 C)))\n        c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n        det (- (* b b) (* 4 a c))]\n    (if det true false)))&quot; &quot;(let [^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 1 3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  )&quot; &quot;(let [^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 1 3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  sphere-intersection\n  )&quot; &quot;(let [^Vector3 camera-location (array [0 1 0])\n      ^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 1 3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  sphere-intersection\n  )&quot; &quot;(let [^Vector3 camera-location (array [0 1 0])\n      ^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 1 -3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  sphere-intersection\n  )&quot; &quot;(let [^Vector3 camera-location (array [0 1 0])\n      ^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 -1 -3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  sphere-intersection\n  )&quot; &quot;P0&quot; &quot;(def P0 (v/vec3 [0 0 0]))&quot; &quot;(def P1 (v/vec3 [0 0 1]))&quot; &quot;(def C (v/vec3 [0 0 3]))&quot; &quot;(def r 1)&quot; &quot;(def det (- (* b b) (* 4 a c)))&quot; &quot;(def C (v/vec3 [0 3 3]))&quot; &quot;(def a (v/dot P1 P1))&quot; &quot;a&quot; &quot;(def b (* 2 (v/dot P1 (- P0 C))))&quot; &quot;b&quot; &quot;(def c (- (v/dot (- P0 C) (- P0 C)) (* r r)))&quot; &quot;c&quot; &quot;(def det2 (- (* b b) (* 4 a c)))&quot; &quot;det2&quot; &quot;(if -1 true false)&quot; &quot;(defn render-plane-and-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-hit sphere-intersection]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if (and sphere-intersection plane-intersection)\n            (let [plane-distance (v/magnitude (- plane-intersection camera-location))\n                  sphere-distance (v/magnitude (- sphere-intersection camera-location))\n                  pixel-intensity (if (&lt; sphere-distance plane-distance) 1.0 0.0)]\n              ;(.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result pixel-intensity 0 0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(inf)&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [plane-intersection (ray-plane sphere-intersection normal)]\n              (let [pixel-intensity (if plane-intersection\n                                      (let [u-tex (mget plane-intersection 0)\n                                            v-tex (mget plane-intersection 2)\n                                            pixel-intensity (+ (checker-texture u-tex v-tex 1) (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n                                        pixel-intensity\n                                        )\n                                      (+  (/ (math/expt (- (v/mget normal 2)) 0) 1.5) (/ (- (v/mget normal 2)) 3)))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))))\n    im))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [plane-intersection2 (ray-plane sphere-intersection normal)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (checker-texture u-tex v-tex 1) (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n                                        pixel-intensity\n                                        )\n                                      (+  (/ (math/expt (- (v/mget normal 2)) 0) 1.5) (/ (- (v/mget normal 2)) 3)))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            \n            ))))\n    im))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [plane-intersection2 (ray-plane sphere-intersection normal)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (checker-texture u-tex v-tex 1) (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n                                        pixel-intensity\n                                        )\n                                      (+ (/ (math/expt (- (v/mget normal 2)) 0) 1.5) (/ (- (v/mget normal 2)) 3)))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 1)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))))\n    im))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 0.2 0])\n        ^Vector3 camera-direction (v/vec3 [1 0 1])\n        ^Vector3 camera-x (v/vec3 [0.5 0 -0.5])\n        ^Vector3 camera-y (v/vec3 [0 0.707 0])\n        ^Vector3 sphere-origin (v/vec3 [3 1 3])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 1 -2]))\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (+ (* 1 (rand)) (double ix)) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (+ (* 1 (rand)) (double iy)) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [reflected-direction (- dir (* 2 (dot dir normal) normal))\n                  plane-intersection2 (ray-plane sphere-intersection reflected-direction)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (* 0.5 (checker-texture u-tex v-tex 1))\n                                                               (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 50))\n                                                                  (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 5))\n                                                                  ))]\n                                        pixel-intensity)\n                                      (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 50))\n                                         (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 5))))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 2)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n              (let [pixel-intensity 0.0]\n                (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n                ))))))\n    im)\n\n\n\n  ;(time (image/show (render-plane-and-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  ;(time (image/show (render-plane) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  ;(time (image/show (render-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;)))&quot; &quot;(+ 1 1)&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 0.2 0])\n        ^Vector3 camera-direction (v/vec3 [1 0 1])\n        ^Vector3 camera-x (v/vec3 [0.5 0 -0.5])\n        ^Vector3 camera-y (v/vec3 [0 0.707 0])\n        ^Vector3 sphere-origin (v/vec3 [3 1 3])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 1 -2]))\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (+ (* 1 (rand)) (double ix)) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (+ (* 1 (rand)) (double iy)) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [reflected-direction (- dir (* 2 (dot dir normal) normal))\n                  plane-intersection2 (ray-plane sphere-intersection reflected-direction)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (* 0.5 (checker-texture u-tex v-tex 1))\n                                                               (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 50))\n                                                                  (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 5))\n                                                                  ))]\n                                        pixel-intensity)\n                                      (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 50))\n                                         (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 5))))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 2)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n              (let [pixel-intensity 0.0]\n                (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n                ))))))\n    im)\n\n\n\n  (time (image/show (render-plane-and-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-plane) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;)))&quot; &quot;(time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 0.2 0])\n        ^Vector3 camera-direction (v/vec3 [1 0 1])\n        ^Vector3 camera-x (v/vec3 [0.5 0 -0.5])\n        ^Vector3 camera-y (v/vec3 [0 0.707 0])\n        ^Vector3 sphere-origin (v/vec3 [3 1 3])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 1 -2]))\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (+ (* 1 (rand)) (double ix)) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (+ (* 1 (rand)) (double iy)) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [reflected-direction (- dir (* 2 (dot dir normal) normal))\n                  plane-intersection2 (ray-plane sphere-intersection reflected-direction)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (* 0.5 (checker-texture u-tex v-tex 1))\n                                                               (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 50))\n                                                                  (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 5))\n                                                                  ))]\n                                        pixel-intensity)\n                                      (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 50))\n                                         (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 5))))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 2)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n              (let [pixel-intensity 0.0]\n                (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n                ))))))\n    im)\n\n\n\n  (time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;)))&quot; &quot;(render-reflective-sphere)&quot; &quot;(ray-sphere)&quot;], :remote []}}</component>
</project>

