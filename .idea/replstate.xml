<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1415023154215">{:repl-history {:ide [], :local [&quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   colour-result (v/vec4 [0.5 0 0.8 1])\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               ; (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;\n(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 300 300)]\n  (view image))\n\n(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.85)\n             (sphere (v3d 250 200 -600) 400 0.85)\n             (sphere (v3d 200 100 -600) 400 0.65)\n             ]\n      image (ray-trace world eye 300 300)]\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 300 300)]\n\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.85)\n             (sphere (v3d 250 200 -600) 400 0.85)\n             (sphere (v3d 200 100 -600) 400 0.65)\n             ]\n      image (ray-trace world eye 300 300)]\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 1000 1000)]\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 100 100)]\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 300 300)]\n  (view image))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               ;(.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 (v/vec4 [0.5 0 0.8 1]))))))))\n     im)))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ([&amp; {:keys [width height title]\n       :or   {width res-x height res-y}\n       :as   params}]\n   (display (apply render (apply concat params)) :title title)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               ;(.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.set colour-result 3 1.0)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.set colour-result 0 1)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.set colour-result 0 1.0)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0 0 0 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.set colour-result 0 (rand))\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0 0 0 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.set colour-result 0 1.0)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 pixel-intensity)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def res-x 100)\n  (def res-y 100)\n  ;; create a new image\n  (def bi (image/new-image res-x res-y))\n  ;; gets the pixels of the image, as an int array\n  (def pixels (image/get-pixels bi)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (print pixel-intensity)\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 (* 1.0 ^long pixel-intensity))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 (* 1.0 1.0))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn checker-texture [x y checker-spacing]\n  (let [xs (math/round (/ (mod x checker-spacing) checker-spacing))\n        ys (math/round (/ (mod y checker-spacing) checker-spacing))]\n    (mod (+ xs ys) 2.0)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 (* 1.0 pixel-intensity))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 pixel-intensity)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(def render-old\n\n  (dotimes [i (* res-x res-y)]\n    (let [x (mod i res-x)\n          y (quot i res-x)\n          plane-intersection (ray-plane camera-location (camera-ray (/ x res-x) (/ y res-y)))]\n      (if plane-intersection\n        (let [u-tex (mget plane-intersection 0)\n              v-tex (mget plane-intersection 2)\n              pixel-intensity (int (checker-texture u-tex v-tex 1))]\n          (aset ^ints pixels i (colours/rgb (* r-rand pixel-intensity) (* g-rand pixel-intensity) (* b-rand pixel-intensity)))))))\n\n\n  (comment (dotimes [i (* res-x res-y)]\n             (aset pixels i (colours/rgb (* r-rand) (* g-rand) (* b-rand)))))\n\n\n  ;; update the image with the newly changed pixel values\n  (image/set-pixels bi pixels)\n\n  ;; view our new work of art\n  ;; the zoom function will automatically interpolate the pixel values\n  (image/show bi :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn render-old\n\n  (dotimes [i (* res-x res-y)]\n    (let [x (mod i res-x)\n          y (quot i res-x)\n          plane-intersection (ray-plane camera-location (camera-ray (/ x res-x) (/ y res-y)))]\n      (if plane-intersection\n        (let [u-tex (mget plane-intersection 0)\n              v-tex (mget plane-intersection 2)\n              pixel-intensity (int (checker-texture u-tex v-tex 1))]\n          (aset ^ints pixels i (colours/rgb (* r-rand pixel-intensity) (* g-rand pixel-intensity) (* b-rand pixel-intensity)))))))\n\n\n  (comment (dotimes [i (* res-x res-y)]\n             (aset pixels i (colours/rgb (* r-rand) (* g-rand) (* b-rand)))))\n\n\n  ;; update the image with the newly changed pixel values\n  (image/set-pixels bi pixels)\n\n  ;; view our new work of art\n  ;; the zoom function will automatically interpolate the pixel values\n  (image/show bi :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn render-old []\n\n  (dotimes [i (* res-x res-y)]\n    (let [x (mod i res-x)\n          y (quot i res-x)\n          plane-intersection (ray-plane camera-location (camera-ray (/ x res-x) (/ y res-y)))]\n      (if plane-intersection\n        (let [u-tex (mget plane-intersection 0)\n              v-tex (mget plane-intersection 2)\n              pixel-intensity (int (checker-texture u-tex v-tex 1))]\n          (aset ^ints pixels i (colours/rgb (* r-rand pixel-intensity) (* g-rand pixel-intensity) (* b-rand pixel-intensity)))))))\n\n\n  (comment (dotimes [i (* res-x res-y)]\n             (aset pixels i (colours/rgb (* r-rand) (* g-rand) (* b-rand)))))\n\n\n  ;; update the image with the newly changed pixel values\n  (image/set-pixels bi pixels)\n\n  ;; view our new work of art\n  ;; the zoom function will automatically interpolate the pixel values\n  (image/show bi :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn render-old []\n\n  (dotimes [i (* res-x res-y)]\n    (let [x (mod i res-x)\n          y (quot i res-x)\n          plane-intersection (ray-plane camera-location (camera-ray (/ x res-x) (/ y res-y)))]\n      (if plane-intersection\n        (let [u-tex (mget plane-intersection 0)\n              v-tex (mget plane-intersection 2)\n              pixel-intensity (int (checker-texture u-tex v-tex 1))]\n          (aset pixels i (colours/rgb (* r-rand pixel-intensity) (* g-rand pixel-intensity) (* b-rand pixel-intensity)))))))\n\n\n  (comment (dotimes [i (* res-x res-y)]\n             (aset pixels i (colours/rgb (* r-rand) (* g-rand) (* b-rand)))))\n\n\n  ;; update the image with the newly changed pixel values\n  (image/set-pixels bi pixels)\n\n  ;; view our new work of art\n  ;; the zoom function will automatically interpolate the pixel values\n  (image/show bi :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def res-x 512)\n  (def res-y 512)\n  ;; create a new image\n  (def bi (image/new-image res-x res-y))\n  ;; gets the pixels of the image, as an int array\n  (def pixels (image/get-pixels bi)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true                      ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [;u-tex (mget plane-intersection 0)\n                   ;v-tex (mget plane-intersection 2)\n                   ;pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(time (show\n        \n        ))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true                      ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 pixel-intensity)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true                      ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   ;pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x  height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true                      ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 pixel-intensity)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true                      ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 pixel-intensity)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width res-x height res-y}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection true                      ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ]\n           (if plane-intersection\n             (let [u-tex 1                                  ;(mget plane-intersection 0)\n                   v-tex 1                                  ;(mget plane-intersection 2)\n                   pixel-intensity (checker-texture u-tex v-tex 1)\n                   ]\n               (.set colour-result 1 1.0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render []\n(let [width (int width)\n      height (int height)\n      colour-result (v/vec4 [0.5 0 0.8 1])\n      ^BufferedImage im (new-image width height)]\n  (dotimes [ix width]\n    (dotimes [iy height]\n      (let [plane-intersection true                         ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n            ]\n        (if plane-intersection\n          (let [u-tex 1                                     ;(mget plane-intersection 0)\n                v-tex 1                                     ;(mget plane-intersection 2)\n                pixel-intensity (checker-texture u-tex v-tex 1)\n                ]\n            (.set colour-result 1 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n  im))&quot; &quot;(defn render []\n(let [width (int res-x)\n      height (int res-y)\n      colour-result (v/vec4 [0.5 0 0.8 1])\n      ^BufferedImage im (new-image width height)]\n  (dotimes [ix width]\n    (dotimes [iy height]\n      (let [plane-intersection true                         ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n            ]\n        (if plane-intersection\n          (let [u-tex 1                                     ;(mget plane-intersection 0)\n                v-tex 1                                     ;(mget plane-intersection 2)\n                pixel-intensity (checker-texture u-tex v-tex 1)\n                ]\n            (.set colour-result 1 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n  im))&quot; &quot;(defn show []\n  (display (render)))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true    ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 (checker-texture u-tex v-tex 1))\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true    ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true                       ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1 (mget plane-intersection 0)\n                  v-tex 1 (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 (checker-texture u-tex v-tex 1))\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1 (mget plane-intersection 0)\n                  v-tex 1 (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 (checker-texture u-tex v-tex 1))\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 (checker-texture u-tex v-tex 1))\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  ;pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 (checker-texture u-tex v-tex 1))\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 ^long pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 1.0)\n              (.copyTo temp colour-result 0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 ^double pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true                       ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true                       ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 ^double pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection  (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex  (mget plane-intersection 0)\n                  v-tex  (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.set colour-result 1 ^double pixel-intensity)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0.5 0 0.8 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection  (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex  (mget plane-intersection 0)\n                  v-tex  (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              ;(.set colour-result 1 ^double pixel-intensity)\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn display\n  \&quot;Displays an image in a new frame\&quot;\n  [^BufferedImage image\n   &amp; {:keys [title]}]\n  (mikera.gui.Frames/displayImage image (str (or title \&quot;Render\&quot;))))&quot; &quot;(time (show))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection  (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex  (mget plane-intersection 0)\n                  v-tex  (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              ;(.set colour-result 1 ^double pixel-intensity)\n              (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (display\n    (let [width (int res-x)\n          height (int res-y)\n          colour-result (v/vec4 [0 0 0 1])\n          ^BufferedImage im (new-image width height)]\n      (dotimes [ix width]\n        (dotimes [iy height]\n          (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n                ]\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    temp (v/vec3)\n                    pixel-intensity (checker-texture u-tex v-tex 1)\n                    ]\n                ;(.set colour-result 1 ^double pixel-intensity)\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n      im)))&quot; &quot;(defn render-old []\n  (let [r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)]\n    (dotimes [i (* res-x res-y)]\n      (let [x (mod i res-x)\n            y (quot i res-x)\n            plane-intersection (ray-plane camera-location (camera-ray (/ x res-x) (/ y res-y)))]\n        (if plane-intersection\n          (let [u-tex (mget plane-intersection 0)\n                v-tex (mget plane-intersection 2)\n                pixel-intensity (int (checker-texture u-tex v-tex 1))]\n            (aset pixels i (colours/rgb (* r-rand pixel-intensity) (* g-rand pixel-intensity) (* b-rand pixel-intensity))))))))\n\n\n  (comment (dotimes [i (* res-x res-y)]\n             (aset pixels i (colours/rgb (* r-rand) (* g-rand) (* b-rand)))))\n\n\n  ;; update the image with the newly changed pixel values\n  (image/set-pixels bi pixels)\n\n  ;; view our new work of art\n  ;; the zoom function will automatically interpolate the pixel values\n  (image/show bi :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (render-old))&quot; &quot;(defn render []\n  (display\n    (let [width (int res-x)\n          height (int res-y)\n          colour-result (v/vec4 [0 0 0 1])\n          r-rand (rand)\n          g-rand (rand)\n          b-rand (rand)\n          ^BufferedImage im (new-image width height)]\n      (dotimes [ix width]\n        (dotimes [iy height]\n          (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n                ]\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    temp (v/vec3)\n                    pixel-intensity (checker-texture u-tex v-tex 1)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n      im)))&quot; &quot;(time (display (render)))&quot; &quot;(time (image/show (render) :zoom 0.4234 :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render) :zoom 0.5 :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def res-x 1000)\n  (def res-y 1000)\n  ;; create a new image\n  (def bi (image/new-image res-x res-y))\n  ;; gets the pixels of the image, as an int array\n  (def pixels (image/get-pixels bi)))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double pixel-intensity ^double pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity 1                         ;(checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(time (image/show (render) :zoom 1 :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(rotate-x 1)&quot; &quot;(ns ray.core\n  ;(:refer-clojure :exclude [* - + == /])\n  (:use clojure.core.matrix)\n  ;(:use clojure.core.matrix.operators)\n  (:require [clojure.math.numeric-tower :as math])\n  (:require [mikera.image.core :as image])\n  ;(:require [mikera.image.colours :as colours])\n\n\n  ;(:require [mikera.vectorz.core :as v])\n  ;(:require [mikera.vectorz.matrix :as m])\n\n  (:require [ray.colours :as c])\n  (:require [mikera.vectorz.core :as v])\n  (:import [java.awt.image BufferedImage])\n  ;(:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n  )&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if false                                         ;plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              ;(.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              ;(.setRGB im ix iy (c/argb-from-vector4 colour-result))\n              )))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection 0                          ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if false                                         ;plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  temp (v/vec3)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(render)&quot; &quot;(ray-plane camera-location (array [0 0 0]) (array [1 1 1]))&quot; &quot;(ray-plane camera-location (array [1 1 1]))&quot; &quot;(ray-plane camera-location (array [1 -1 1]))&quot; &quot;(ns ray.core\n  (:refer-clojure :exclude [* - + == /])\n  (:use clojure.core.matrix)\n  (:use clojure.core.matrix.operators)\n  (:require [clojure.math.numeric-tower :as math])\n  (:require [mikera.image.core :as image])\n  ;(:require [mikera.image.colours :as colours])\n\n\n  ;(:require [mikera.vectorz.core :as v])\n  ;(:require [mikera.vectorz.matrix :as m])\n\n  (:require [ray.colours :as c])\n  (:require [mikera.vectorz.core :as v])\n  (:import [java.awt.image BufferedImage])\n  ;(:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n  )&quot; &quot;(time (image/show (render) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(def camera-location (v/vec3 [0 1 0]))&quot; &quot;(def ^Vector3 camera-location (v/vec3 [0 1 0]))&quot; &quot;(defn camera-ray\n  \&quot;x and y are coordinates from 0 to 1, starting at the top left of the image\&quot;\n  [x y]\n  (let [^Vector3 camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])]\n    (+ (* 2 (- x 0.5) camera-x) (* -2 (- y 0.5) camera-y) camera-direction)))&quot; &quot;(defn ray-plane [P0 P1]\n  ;Ray-(ground)Plane Intersection:\n  ;where the ray is defined as P0+tP1 with parameter t\n  ;and the plane is the x-z (ground) plane (y=0)\n  ;P0 and P1 are matrix.core vectorz v/vec3s (vectors)\n  (if-not (zero? (mget P1 1))\n    (let [t (- (/ (mget P0 1) (mget P1 1)))]\n      (if (pos? t)\n        (+ P0 (* P1 t))))))&quot; &quot;(defn ray-plane ^Vector3 [P0 P1]\n  ;Ray-(ground)Plane Intersection:\n  ;where the ray is defined as P0+tP1 with parameter t\n  ;and the plane is the x-z (ground) plane (y=0)\n  ;P0 and P1 are matrix.core vectorz v/vec3s (vectors)\n  (if-not (zero? (mget P1 1))\n    (let [t (- (/ (mget P0 1) (mget P1 1)))]\n      (if (pos? t)\n        (+ P0 (* P1 t))))))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true                       ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true\n              tmp (camera-ray (/ ix res-x) (/ iy res-y))    ;(ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex 1                                   ;(mget plane-intersection 0)\n                  v-tex 1                                   ;(mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection true (ray-plane camera-location (v/vec3 [1 -1 0])) ;(ray-plane camera-location \n        ; (camera-ray (/\n        ; ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render []\n  (let [width (int res-x)\n        height (int res-y)\n        colour-result (v/vec4 [0 0 0 1])\n        r-rand (rand)\n        g-rand (rand)\n        b-rand (rand)\n        ^BufferedImage im (new-image width height)]\n    (dotimes [ix width]\n      (dotimes [iy height]\n        (let [plane-intersection (ray-plane camera-location (v/vec3 [1 -1 0])) ;(ray-plane camera-location \n        ; (camera-ray (/\n        ; ix res-x) (/ iy res-y)))\n              ]\n          (if plane-intersection\n            (let [u-tex (mget plane-intersection 0)\n                  v-tex (mget plane-intersection 2)\n                  pixel-intensity (checker-texture u-tex v-tex 1)\n                  ]\n              (.setValues colour-result ^double (* r-rand pixel-intensity) ^double (* g-rand pixel-intensity) ^double (* b-rand pixel-intensity) 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(time (render))&quot;], :remote []}}</component>
</project>

