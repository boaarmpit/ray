<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1416758436488">{:repl-history {:ide [], :local [&quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (recur remaining (conj processed (inc (item))))))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (print item)\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(incr '(2 4 6))&quot; &quot;(incr 2 4 6)&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (print item \&quot;\\n\&quot;)\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (print remaining item to-process \&quot;\\n\&quot;)\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(2)&quot; &quot;(+ 1 1)&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if to-process\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        ; (print remaining item to-process \&quot;\\n\&quot;)\n        (recur remaining (conj processed 0))\n        ;(recur remaining (conj processed (inc (item))))\n        )\n      processed)))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if to-process\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        ; (print remaining item to-process \&quot;\\n\&quot;)\n        (recur remaining (conj processed (inc item)))\n        ;(recur remaining (conj processed (inc (item))))\n        )\n      processed)))&quot; &quot;(incr [2 4 6])&quot; &quot;(print (incr [2 4 6]))&quot; &quot;(defn better-symmetrize-body-parts\n  \&quot;Expects a seq of maps which have a :name and :size\&quot;\n  [to-process]\n  (reduce (fn [processed part]\n            (let [processed (conj processed part)]\n              processed))\n          []\n          to-process))&quot; &quot;(defn incr2\n  [to-process]\n  (reduce (fn [processed part]\n            (let [processed (conj processed part)]\n              processed))\n          []\n          to-process))&quot; &quot;(print (incr2[2 4 6]))&quot; &quot;(defn incr2\n  [to-process]\n  (reduce (fn [processed part]\n            (let [processed (conj processed part)]\n              (conj processed (inc part))))\n          []\n          to-process))&quot; &quot;(defn incr2\n  [to-process]\n  (reduce (fn [processed part]\n            (print processed part \&quot;\\n\&quot;)\n            (let [processed (conj processed part)]\n              (conj processed (inc part))))\n          []\n          to-process))&quot; &quot;(defn incr2 [to-process]\n  (reduce (fn [processed part]\n            (print processed part \&quot;\\n\&quot;)\n            (let [processed (conj processed part)]\n              (conj processed (inc part))))\n          []\n          to-process))&quot; &quot;(print (incr2 [2 4 6]))&quot; &quot;(time (image/show (render-spheres-and-plane 200 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-spheres-and-plane 500 3) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-plane0]]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;my-sphere0 &quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn trace-ray2 \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  {:pixel-colour (v/vec3 [0 0 0])})&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ;^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n        \n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ;^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n        \n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray 0                                           ;(Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ]\n          (let [pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(time (image/show (test-scene 100 0) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ;^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n        \n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray 0                                           ;(Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ]\n          (let [pixel-colour ^Vector3 (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn trace-ray2 \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  {:pixel-colour Vector3 (v/vec3 [1 0 0])})&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ;^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n        pixel-colour ^Vector3 (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray 0                                           ;(Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ]\n          (let [\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ;^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n        \n        ray 0                                           ;(Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n        pixel-colour ^Vector3 (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ;^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n        \n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray 0            ;(Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour ^Vector3 (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn trace-ray2 \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  {:pixel-colour (array [1 0 0])})&quot; &quot;(defn trace-ray2 \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  {:pixel-colour (v/vec3 [1 0 0])})&quot; &quot;(defn trace-ray2 \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  {:pixel-colour [1 0 0]})&quot; &quot;(array [1 0 0])&quot; &quot;(v/vec3 [1 0 0])&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (v/vec3 [0 -2 2]))\n        ;my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0 -1])\n        ;                        :camera-direction ^Vector3 (v/vec3 [0 0 1])\n        ;                        :camera-x         ^Vector3 (v/vec3 [1 0 0])\n        ;                        :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n        ;\n        ;\n        ;sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n        ;                                    :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n        ;                                    :phong-exponent 5 :reflectivity 0.5})\n        ;\n        ;\n        ;my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        ;my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n        ;\n        ;plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n        ;                                  :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n        ;                                  :phong-exponent 5 :reflectivity 1})\n        ;\n        ;my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n        ;                       :u-axis      (v/vec [1 0 0])\n        ;                       :v-axis      (v/vec [0 0 1])\n        ;                       :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n        ;                       :surface     plane-surface})\n        ;\n        ;\n        ;scene-objects [my-sphere0 my-plane0]\n        my-camera 0\n        scene-objects 0\n        light-direction 0\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray 0            ;(Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour ^Vector3 (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(time (image/show (test-scene 200 0) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (test-scene 300 0) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 0 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (array [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 0 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 0 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [0 -1 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 0 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (array [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 0 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 0 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 0 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn trace-ray2 \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  (let [rays (repeat (count scene-objects) ray)\n        intersections (map intersect scene-objects rays)\n        closest-intersection (reduce closest intersections)]\n    (if (:intersection closest-intersection)\n      (let [\n            intersection (:intersection closest-intersection)\n            scene-object (:scene-object closest-intersection)\n            normal (:normal closest-intersection)\n            eye-direction (- (:ray-direction ray))\n            reflectivity (:reflectivity (:surface scene-object))\n            reflected-ray (if (and reflectivity (not (zero? reflectivity))) (reflect scene-object ray intersection normal))\n            pixel-colour (if (and (&gt; reflection-depth 0) reflected-ray)\n                                    (+ (* reflectivity (:pixel-colour (trace-ray reflected-ray scene-objects light-direction (- reflection-depth 1))))\n                                       (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction}))\n                                    (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                                    )]\n        {:pixel-colour pixel-colour :reflected-ray (reflect scene-object ray intersection normal)})\n      {:pixel-colour (array [0 0 0])}\n      )))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray2 ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn trace-ray \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  (let [rays (repeat (count scene-objects) ray)\n        intersections (map intersect scene-objects rays)\n        closest-intersection (reduce closest intersections)]\n    (if (:intersection closest-intersection)\n      (let [\n            intersection (:intersection closest-intersection)\n            scene-object (:scene-object closest-intersection)\n            normal (:normal closest-intersection)\n            eye-direction (- (:ray-direction ray))\n            reflectivity (:reflectivity (:surface scene-object))\n            reflected-ray (if (and reflectivity (not (zero? reflectivity))) (reflect scene-object ray intersection normal))\n            pixel-colour (if (and (&gt; reflection-depth 0) reflected-ray)\n                                    (+ (* reflectivity (:pixel-colour (trace-ray reflected-ray scene-objects light-direction (- reflection-depth 1))))\n                                       (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction}))\n                                    (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                                    )]\n        {:pixel-colour pixel-colour :reflected-ray (reflect scene-object ray intersection normal)})\n      {:pixel-colour (array [0 0 0])}\n      )))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render-spheres-and-plane \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (array [0 0 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (array [0 (/ (math/sqrt 3) 2) 0])\n                                :camera-direction ^Vector3 (array [0 0 1])\n                                :camera-x         ^Vector3 (array [1 0 0])\n                                :camera-y         ^Vector3 (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 1})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                           :phong-weigh    0.9 :phong-colour (array [0 1 0])\n                                           :phong-exponent 5 :reflectivity 1})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                           :phong-weigh    0.9 :phong-colour (array [0 0 1])\n                                           :phong-exponent 5 :reflectivity 1})\n\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (array [-1 0 3]) :radius 1 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [1 0 0])\n                               :u-axis      (array [0 1 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [0 1 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n        my-plane1 (map-&gt;Plane {:plane-point (array [-1 0 0])\n                               :u-axis      (array [0 0 1])\n                               :v-axis      (array [0 1 0])\n                               :normal      (- (v/cross-product! (v/vec [0 0 1]) (v/vec [0 1 0])))\n                               :surface     plane-surface})\n\n        my-plane2 (map-&gt;Plane {:plane-point (array [0 0 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n        my-plane3 (map-&gt;Plane {:plane-point (array [0 (math/sqrt 3) 0])\n                               :u-axis      (array [0 0 1])\n                               :v-axis      (array [1 0 0])\n                               :normal      (- (v/cross-product! (v/vec [0 0 1]) (v/vec [1 0 0])))\n                               :surface     plane-surface})\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane0 my-plane1 my-plane2 my-plane3]]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn render-3spheres \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (array [0 0 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (array [0 0.5 1])\n                                :camera-direction ^Vector3 (array [0 0 1])\n                                :camera-x         ^Vector3 (array [1 0 0])\n                                :camera-y         ^Vector3 (array [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (array [1 0 0])\n                                            :phong-weigh    1 :phong-colour (array [1 1 1])\n                                            :phong-exponent 50 :reflectivity 0.8})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (array [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (array [1 0 1])\n                                            :phong-exponent 5 :reflectivity 0.8})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (array [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (array [0 1 1])\n                                            :phong-exponent 2 :reflectivity 0.8})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (array [-1 0 3]) :radius 1 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    1 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5\n                                          :reflectivity   1})\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(dot a a)&quot; &quot;(cross a b)&quot; &quot;(cross a a)&quot; &quot;(time (dotimes (dot a a)))&quot; &quot;(time (dotimes (dot a a) 10))&quot; &quot;(time (dotimes [i 10] (dot a a)))&quot; &quot;(def b (v/vec3 [1 2 3]))&quot; &quot;(time (dotimes [i 1000] (dot a a)))&quot; &quot;(time (dotimes [i 10000] (dot a a)))&quot; &quot;(time (dotimes [i 10000] (dot b b)))&quot; &quot;(time (dotimes [i 10000] (cross b b)))&quot; &quot;(time (dotimes [i 10000] (cross a a)))&quot; &quot;(time (dotimes [i 100] (def a (v/vec3 [1 2 3]))))&quot; &quot;(time (dotimes [i 1000] (def a (v/vec3 [1 2 3]))))&quot; &quot;(time (dotimes [i 1000] (def a (array [1 2 3]))))&quot; &quot;a&quot; &quot;(time (image/show (render-spheres-and-plane 300 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-3spheres 300 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-3spheres 450 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-3spheres 500 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-3spheres 500 3) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-3spheres 500 10) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (array [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (array [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 (v/vec4 colour-result)))))))\n    im))&quot; &quot;(defn trace-ray \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  (let [rays (repeat (count scene-objects) ray)\n        intersections (map intersect scene-objects rays)\n        closest-intersection (reduce closest intersections)]\n    (if (:intersection closest-intersection)\n      (let [\n            intersection (:intersection closest-intersection)\n            scene-object (:scene-object closest-intersection)\n            normal (:normal closest-intersection)\n            eye-direction (- (:ray-direction ray))\n            reflectivity (:reflectivity (:surface scene-object))\n            reflected-ray (if (and reflectivity (not (zero? reflectivity))) (reflect scene-object ray intersection normal))\n            pixel-colour (if (and (&gt; reflection-depth 0) reflected-ray)\n                                    (+ (* reflectivity (:pixel-colour (trace-ray reflected-ray scene-objects light-direction (- reflection-depth 1))))\n                                       (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction}))\n                                    (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                                    )]\n        {:pixel-colour pixel-colour :reflected-ray (reflect scene-object ray intersection normal)})\n      {:pixel-colour (v/vec3 [0 0 0])}\n      )))&quot; &quot;(time (image/show (test-scene 300 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(def a (array [1 2 3]))&quot; &quot;(v/dot a a)&quot; &quot;(v/normalise a a)&quot; &quot;(normalise a a)&quot; &quot;(normalise a)&quot; &quot;(v/normalise a)&quot; &quot;(defn camera-ray [^Camera camera res-x res-y x y]\n  (let [camera-direction (:camera-direction camera)\n        camera-x (:camera-x camera)\n        camera-y (:camera-y camera)]\n    (v/normalise (+ (* 2 (- (/ (double x) res-x) 0.5) camera-x) (* -2 (- (/ (double y) res-y) 0.5) camera-y) camera-direction)))\n  ;(v/normalise (+ (* 2 (- (/ (+ (rand) (double x)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double y)) res-y) 0.5) camera-y) camera-direction))\n  )&quot; &quot;(defprotocol SceneObject\n  (intersect [this ray] [this ray camera-origin])\n  (reflect [this ray intersection normal]))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(time (image/show (test-scene 500 0) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy)\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy)\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) dir\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) dir\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(time (image/show (test-scene 500 1) :title \&quot;Isn't it beautiful?\&quot;))&quot;], :remote []}}</component>
</project>

