<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1416842404526">{:repl-history {:ide [], :local [&quot;(defn camera-ray [^Camera camera res-x res-y x y]\n  (let [camera-direction (:camera-direction camera)\n        camera-x (:camera-x camera)\n        camera-y (:camera-y camera)]\n    (v/normalise (+ (* 2 (- (/ (double x) res-x) 0.5) camera-x) (* -2 (- (/ (double y) res-y) 0.5) camera-y) camera-direction)))\n  ;(v/normalise (+ (* 2 (- (/ (+ (rand) (double x)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double y)) res-y) 0.5) camera-y) camera-direction))\n  )&quot; &quot;(defprotocol SceneObject\n  (intersect [this ray] [this ray camera-origin])\n  (reflect [this ray intersection normal]))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-plane0]\n\n\n        ]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [\n              ]\n          (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n                pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy)\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy)\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) dir\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (array [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (array [0 -0.5 -1])\n                                :camera-direction (array [0 0 1])\n                                :camera-x         (array [1 0 0])\n                                :camera-y         (array [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (array [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (array [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (array [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (array [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (array [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (array [1 1 1])\n                                          :phong-weigh    0 :phong-colour (array [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (array [0 -1 0])\n                               :u-axis      (array [1 0 0])\n                               :v-axis      (array [0 0 1])\n                               :normal      (- (cross! (array [1 0 0]) (array [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (array [0 0 1])\n        camera-x (array [1 0 0])\n        camera-y (array [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) dir\n                        )\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn trace-ray \&quot;Traces a ray reflection-depth times and returns a colour.  Returns black if no object found.\&quot;\n  [ray scene-objects light-direction reflection-depth]\n  (let [rays (repeat (count scene-objects) ray)\n        intersections (map intersect scene-objects rays)\n        closest-intersection (reduce closest intersections)]\n    (if (:intersection closest-intersection)\n      (let [\n            intersection (:intersection closest-intersection)\n            scene-object (:scene-object closest-intersection)\n            normal (:normal closest-intersection)\n            eye-direction (- (:ray-direction ray))\n            reflectivity (:reflectivity (:surface scene-object))\n            reflected-ray (if (and reflectivity (not (zero? reflectivity))) (reflect scene-object ray intersection normal))\n            pixel-colour (if (and (&gt; reflection-depth 0) reflected-ray)\n                           (+ (* reflectivity (:pixel-colour (trace-ray reflected-ray scene-objects light-direction (- reflection-depth 1))))\n                              (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction}))\n                           (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                           )]\n        {:pixel-colour pixel-colour :reflected-ray (reflect scene-object ray intersection normal)})\n      {:pixel-colour (array [0 0 0])}\n      )))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) ^Vector3 (camera-ray my-camera resolution resolution ix iy))\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [                                              ;ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) ^Vector3 (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) Vector3 (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        \n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) Vector3 (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) dir)\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn camera-ray2 [^Camera camera res-x res-y x y]\n  (let [camera-direction (:camera-direction camera)\n        camera-x (:camera-x camera)\n        camera-y (:camera-y camera)]\n    (v/normalise (+ (* 2 (- (/ res-x) 0.5) camera-x) (* -2 (- (/ res-y) 0.5) camera-y) camera-direction)))\n  ;(v/normalise (+ (* 2 (- (/ (+ (rand) (double x)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double y)) res-y) 0.5) camera-y) camera-direction))\n  )&quot; &quot;(defn camera-ray2 [^Camera camera res-x res-y x y]\n  (let [camera-direction (:camera-direction camera)\n        camera-x (:camera-x camera)\n        camera-y (:camera-y camera)]\n    (v/normalise (+ (* 2 (- (/ (double x) res-x) 0.5) (double camera-x)) (* -2 (- (/ (double y) res-y) 0.5) (double camera-y)) camera-direction)))\n  ;(v/normalise (+ (* 2 (- (/ (+ (rand) (double x)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double y)) res-y) 0.5) camera-y) camera-direction))\n  )&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [^double resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray2 my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])\n        dir camera-direction\n        res-x resolution\n        res-y resolution\n\n        pixel-colour (array [1 0 0])                                        ;(:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray2 my-camera resolution resolution ix iy))\n              ;pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn camera-ray2 [^Camera camera res-x res-y x y]\n  (let [camera-direction (:camera-direction camera)\n        camera-x (:camera-x camera)\n        camera-y (:camera-y camera)]\n    (v/normalise (+ (* 2 (- (/ (double x) res-x) 0.5) camera-x) (* -2 (- (/ (double y) res-y) 0.5) camera-y) camera-direction)))\n  ;(v/normalise (+ (* 2 (- (/ (+ (rand) (double x)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double y)) res-y) 0.5) camera-y) camera-direction))\n  )&quot; &quot;(time (image/show (test-scene 1000 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (test-scene 500 1) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-plane0]\n        ;camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        ;camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        ]                                                   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        ;(.set dir camera-direction)\n        ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        ;(v/normalise! dir)\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n              pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n              pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n              pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n              pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n          (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n          (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(defn test-scene \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        light-direction (v/normalise (v/vec3 [0 -2 2]))\n        my-camera (map-&gt;Camera {:camera-location  (v/vec3 [0 -0.5 -1])\n                                :camera-direction (v/vec3 [0 0 1])\n                                :camera-x         (v/vec3 [1 0 0])\n                                :camera-y         (v/vec3 [0 1 0])})\n\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec3 [1 1 1])\n                                            :phong-weigh    0.9 :phong-colour (v/vec3 [1 0 0])\n                                            :phong-exponent 5 :reflectivity 0.5})\n\n\n        my-sphere0 (map-&gt;Sphere {:center (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface0})\n        my-sphere2 (map-&gt;Sphere {:center (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface0})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.2 :lambert-colour (v/vec3 [1 1 1])\n                                          :phong-weigh    0 :phong-colour (v/vec3 [1 1 1])\n                                          :phong-exponent 5 :reflectivity 1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec3 [0 -1 0])\n                               :u-axis      (v/vec3 [1 0 0])\n                               :v-axis      (v/vec3 [0 0 1])\n                               :normal      (- (cross! (v/vec3 [1 0 0]) (v/vec3 [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-plane0]\n        ;camera-direction (v/vec3 [0 0 1])\n        ;camera-x (v/vec3 [1 0 0])\n        ;camera-y (v/vec3 [0 1 0])\n        ;dir camera-direction\n        ;res-x resolution\n        ;res-y resolution\n\n        ]                                                   ;setup scene\n    ;(dotimes [ix resolution]\n    ;  (dotimes [iy resolution]\n    ;    ;(.set dir camera-direction)\n    ;    ;(v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n    ;    ;(v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n    ;    ;(v/normalise! dir)\n    ;    (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))\n    ;          pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n    ;          pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n    ;          pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n    ;          pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n    ;      (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n    ;      (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n    im))&quot; &quot;(time (image/show (test-scene 500 0) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defprotocol TextureObject [scale]\n  (texture [this {:keys [u-coord v-coord]}])\n  )&quot; &quot;(defprotocol TextureObject\n  (texture [this {:keys [u-coord v-coord]}])\n  )&quot; &quot;(texture my-texture 1 1)&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (* 0.7 (mod (+ us vs) 2.0)))))&quot; &quot;(defprotocol TextureObject\n  (test-it [])\n  (texture [this {:keys [u v]}]))&quot; &quot;(defprotocol TextureObject\n  (test-it [] (print \&quot;test\&quot;))\n  (texture [this {:keys [u v]}]))&quot; &quot;(defprotocol TextureObject\n  (test-it [this] (print \&quot;test\&quot;))\n  (texture [this {:keys [u v]}]))&quot; &quot;(defprotocol TextureObject\n  (test-it [this])\n  (texture [this {:keys [u v]}]))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (test-it [this] (print \&quot;test\&quot;))\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (* 0.7 (mod (+ us vs) 2.0)))))&quot; &quot;(test-it my-texture)&quot; &quot;(defprotocol TextureObject\n  (test-it [this word])\n  (texture [this {:keys [u v]}]))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (test-it [this word] (print word))\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (* 0.7 (mod (+ us vs) 2.0)))))&quot; &quot;(defprotocol TextureObject\n  (test-it [this {:keys [word]}])\n  (texture [this {:keys [u v]}]))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (test-it [this {keys: [word]}] (print :word))\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (* 0.7 (mod (+ us vs) 2.0)))))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (test-it [this ] (print word))\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (* 0.7 (mod (+ us vs) 2.0)))))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (test-it [this {:keys [word]}] (print word))\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (* 0.7 (mod (+ us vs) 2.0)))))&quot; &quot;(test-it my-texture \&quot;testword\&quot;)&quot; &quot;(texture my-texture {:u 1 :v 1})&quot; &quot;(texture my-texture {:u 1 :v 2})&quot; &quot;(texture my-texture {:u 1 :v 3})&quot; &quot;(texture my-texture {:u 1 :v 4})&quot; &quot;(texture my-texture {:u 1 :v 6})&quot; &quot;(texture my-texture {:u 1 :v 7})&quot; &quot;(texture my-texture {:u 1 :v 8})&quot; &quot;(texture my-texture {:u 1 :v 9})&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (test-it [this {:keys [word]}] (print word))\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (mod (+ us vs) 2.0))))&quot; &quot;(test-it my-texture {:word \&quot;theword\&quot;})&quot; &quot;(texture my-texture {:u 1 :v 10})&quot; &quot;(defrecord Colour []\n  TextureObject\n  (texture [this {:keys [colour]}]\n    colour))&quot; &quot;(defrecord SolidColour []\n  TextureObject\n  (texture [this {:keys [colour]}]\n    colour))&quot; &quot;(def my-texture (-&gt;SolidColour))&quot; &quot;(def my-texture SolidColour.)&quot; &quot;(def my-texture .SolidColour)&quot; &quot;(def my-texture -&gt;SolidColour)&quot; &quot;(texture my-texture {:colour \&quot;red\&quot;})&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this {:keys [u]}]\n    colour))&quot; &quot;(texture my-texture [])&quot; &quot;(defprotocol TextureObject\n  (texture [this {:keys [u v]}])\n  (texture [this]))&quot; &quot;(defprotocol TextureObject\n  (texture [this &amp; {:keys [u v]}] [this {:keys [u v]}]))&quot; &quot;(texture my-texture 0)&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this &amp; {:keys [u v]}]\n    colour))&quot; &quot;(texture my-texture 0 0)&quot; &quot;(defprotocol TextureObject\n  (texture [this {:keys [u v]}]))&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this]\n    colour))&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this {:keys [u v]}]\n    colour))&quot; &quot;(texture my-texture (:u 1 :v 5))&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this {:keys [test-key]}]\n    test-key))&quot; &quot;(texture my-texture {:test-key \&quot;blue\&quot;})&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this {:keys []}]\n    test-key))&quot; &quot;(defprotocol TextureObject\n  (texture [this &amp; {:keys []}]))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (texture [this &amp; {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (mod (+ us vs) 2.0))))&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this {:keys []}]\n    colour))&quot; &quot;(defprotocol TextureObject\n  (texture [this {:keys []}]))&quot; &quot;(defprotocol TextureObject\n  (texture [this &amp; ignore] [this {:keys []}]))&quot; &quot;(texture my-texture {})&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this &amp; ignore]\n    colour))&quot; &quot;(texture my-texture \&quot;test\&quot;)&quot; &quot;(defprotocol TextureObject\n  (texture [this] [this {:keys []}]))&quot; &quot;(defprotocol TextureObject\n  (texture [this] [this {:keys [u v]}]))&quot; &quot;(defrecord Checker [scale]\n  TextureObject\n  (texture [this {:keys [u v]}]\n    (let [us (math/round (/ (mod u scale) scale))\n          vs (math/round (/ (mod v scale) scale))]\n      (mod (+ us vs) 2.0))))&quot; &quot;(defrecord SolidColour [colour]\n  TextureObject\n  (texture [this {:keys []}]\n    (texture this))\n  (texture [this]\n    colour))&quot; &quot;(texture my-texture {:u 1 :v 5})&quot; &quot;(def my-texture (map-&gt;Checker {:scale 10}))&quot; &quot;(def my-texture (map-&gt;SolidColour {:colour \&quot;red\&quot;}))&quot; &quot;(texture my-texture \&quot;bafd\&quot;)&quot; &quot;(texture my-texture \&quot;bafd\&quot; 2)&quot; &quot;(texture my-texture)&quot; &quot;(defprotocol SurfaceObject\n  (surface-colour [this {:keys [normal light-direction eye-direction]}]))&quot; &quot;(defprotocol SurfaceObject\n  (surface-colour [this {:keys [normal light-direction eye-direction u-coord v-coord]}]))&quot; &quot;(defrecord Lambertian [lambert-colour]\n  SurfaceObject\n  (surface-colour [this {:keys [normal light-direction eye-direction u-coord v-coord] :or {}}]\n    (let [lambert-coefficient (- (v/dot normal light-direction))]\n      (* (lambert-colour {:u u-coord :v v-coord}) lambert-coefficient))))&quot;], :remote []}}</component>
</project>

