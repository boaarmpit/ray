<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1415005955197">{:repl-history {:ide [], :local [&quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:require [colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  ;(:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  ;(:require [mikera.vectorz.core :as v])\n  ;(:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  ;(:require [mikera.vectorz.core :as v])\n  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.colours\n  (:require [mikera.vectorz.core :as v])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz]))&quot; &quot;(defproject ray \&quot;0.1.0-SNAPSHOT\&quot;\n            :description \&quot;FIXME: write description\&quot;\n            :url \&quot;http://example.com/FIXME\&quot;\n            :license {:name \&quot;Eclipse Public License\&quot;\n                      :url  \&quot;http://www.eclipse.org/legal/epl-v10.html\&quot;}\n            :dependencies [[org.clojure/clojure \&quot;1.6.0\&quot;]\n                           [net.mikera/core.matrix \&quot;0.30.2\&quot;]\n                           [net.mikera/vectorz-clj \&quot;0.26.1\&quot;]\n                           [net.mikera/imagez \&quot;0.4.1\&quot;]\n                           [org.clojure/math.numeric-tower \&quot;0.0.4\&quot;]\n\n                           [net.mikera/vectorz \&quot;0.8.1\&quot;]]\n            )&quot; &quot;(ns ray.image-test\n;  (:require [mikera.vectorz.core :as v])\n;  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n;  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz]))&quot; &quot;(import java.awt.image)&quot; &quot;(import java.awt)&quot; &quot;(import java.awt.image BufferedImage)&quot; &quot;(import java.util.Date)&quot; &quot;(import java.awt.image.BufferedImage)&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n;  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image]))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:require [enlight.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz]))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [scene-desc\n                   &amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ([scene\n    &amp; {:keys [width height title]\n       :or   {width 256 height 256}\n       :as   params}]\n   (display (apply render scene (apply concat params)) :title title)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 1 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [(rand) (rand) (rand) 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         \n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height\n                 colour-result (v/vec4 [(rand) (rand) (rand) 1])]\n         (let [x 1]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         \n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               colour-result (v/vec4 [(rand) (rand) (rand) 1])]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(show 0)&quot; &quot;(render)&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               colour-result 1                              ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 256 height 256}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(ns ray.core\n  (:refer-clojure :exclude [* - + == /])\n  (:use clojure.core.matrix)\n  (:use clojure.core.matrix.operators)\n  (:require [clojure.math.numeric-tower :as math])\n  (:require [mikera.image.core :as image])\n  (:require [mikera.image.colours :as colours]))&quot; &quot;(time (dotimes [i (* res-x res-y)]\n        (aset pixels i (colours/rgb (* r-rand) (* g-rand) (* b-rand)))))&quot; &quot;(time (dotimes [i (* res-x res-y)]\n        (aset pixels i (colours/rgb 1 0 0))))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ([scene\n    &amp; {:keys [width height title]\n       :or   {width 256 height 256}\n       :as   params}]\n   (display (apply render (apply concat params)) :title title)))&quot; &quot;(time  (display (render)))&quot; &quot;(ns ray.image-test\n  (:require [mikera.vectorz.core :as v])\n  (:require [ray.colours :as c])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz]))&quot; &quot;(display (render))&quot; &quot;(show)&quot; &quot;(ns ray.core\n  (:refer-clojure :exclude [* - + == /])\n  (:use clojure.core.matrix)\n  (:use clojure.core.matrix.operators)\n  (:require [clojure.math.numeric-tower :as math])\n  (:require [mikera.image.core :as image])\n  (:require [mikera.image.colours :as colours])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n  )&quot; &quot;(ns ray.core\n  (:refer-clojure :exclude [* - + == /])\n  (:use clojure.core.matrix)\n  (:use clojure.core.matrix.operators)\n  (:require [clojure.math.numeric-tower :as math])\n  (:require [mikera.image.core :as image])\n  (:require [mikera.image.colours :as colours])\n  (:require [mikera.vectorz.core :as v])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n  )&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (colours/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(ns ray.core\n  (:refer-clojure :exclude [* - + == /])\n  (:use clojure.core.matrix)\n  (:use clojure.core.matrix.operators)\n  (:require [clojure.math.numeric-tower :as math])\n  (:require [mikera.image.core :as image])\n  (:require [mikera.image.colours :as colours])\n  (:require [ray.colours :as c])\n  (:require [mikera.vectorz.core :as v])\n  (:import [java.awt.image BufferedImage])\n  (:import [mikera.image])\n  (:import [mikera.vectorz Vector3 Vector4 AVector Vectorz])\n  )&quot; &quot;(defn display\n  \&quot;Displays an image in a new frame\&quot;\n  [^BufferedImage image\n   &amp; {:keys [title]}]\n  (mikera.gui.Frames/displayImage image (str (or title \&quot;Enlight Render\&quot;))))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 1024 height 1024}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ([&amp; {:keys [width height title]\n       :or   {width 256 height 256}\n       :as   params}]\n   (display (apply render (apply concat params)) :title title)))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ((display (apply render (apply concat params)) :title title)))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ([]\n   (display (apply render (apply concat params)) :title title)))&quot; &quot;(defn show\n  \&quot;Renders and displays a scene in a new Frame\&quot;\n  ([&amp; {:keys [width height title]\n       :or   {width res-x height res-y}\n       :as   params}]\n   (display (apply render (apply concat params)) :title title)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width x-res height y-res}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;(v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(do\n  ;;image horizontal and vertical resolution\n  (def res-x 500)\n  (def res-y 500)\n  ;; create a new image\n  (def bi (image/new-image res-x res-y))\n  ;; gets the pixels of the image, as an int array\n  (def pixels (image/get-pixels bi)))&quot; &quot;im&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width x-res height y-res}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               color-result (v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn new-image\n  \&quot;Creates a new blank image\&quot;\n  ([w h]\n   (mikera.gui.ImageUtils/newImage (int w) (int h))))&quot; &quot;()&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;color-result (v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ;color-result (v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               (if plane-intersection\n                 (let [u-tex (mget plane-intersection 0)\n                       v-tex (mget plane-intersection 2)\n                       pixel-intensity (int (checker-texture u-tex v-tex 1))\n                       color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])]\n                   (.setRGB im ix iy (c/argb-from-vector4 colour-result))))])))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               (if plane-intersection\n                 (let [u-tex (mget plane-intersection 0)\n                       v-tex (mget plane-intersection 2)\n                       pixel-intensity (int (checker-texture u-tex v-tex 1))\n                       ;color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n                       ]\n                   (.setRGB im ix iy (c/argb-from-vector4 colour-result))))])))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               ;(if plane-intersection\n               ;  (let [u-tex (mget plane-intersection 0)\n               ;        v-tex (mget plane-intersection 2)\n               ;        pixel-intensity (int (checker-texture u-tex v-tex 1))\n               ;        ;color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n               ;        ]\n               ;    (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n               ])))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))\n               (if plane-intersection\n               (prin \&quot;test\&quot;)\n               ;  (let [u-tex (mget plane-intersection 0)\n               ;        v-tex (mget plane-intersection 2)\n               ;        pixel-intensity (int (checker-texture u-tex v-tex 1))\n               ;        ;color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n               ;        ]\n               ;    (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n               )\n               ])))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n               (if plane-intersection\n               (print \&quot;test\&quot;)\n               ;  (let [u-tex (mget plane-intersection 0)\n               ;        v-tex (mget plane-intersection 2)\n               ;        pixel-intensity (int (checker-texture u-tex v-tex 1))\n               ;        ;color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n               ;        ]\n               ;    (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n               )\n               )))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (print \&quot;test\&quot;)\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))\n                   ;color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n                   ]\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (print \&quot;test\&quot;)\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))\n                   color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n                   ]\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (print \&quot;test\&quot;)\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   ;pixel-intensity (int (checker-texture u-tex v-tex 1))\n                   ;color-result (v/vec4 [pixel-intensity pixel-intensity pixel-intensity 1])\n                   ]\n               ;(.setRGB im ix iy (c/argb-from-vector4 colour-result))\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               color-result (v/vec4 [(rand) (rand) (rand) 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               color-result (v/vec4 [0 1 0 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;color-result (v/vec4 [0 1 0 1])\n               ]\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn set-colour [^Vector4 colour-result]\n       (.set colour-result 0 1.0))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [x 1\n               ;color-result (v/vec4 [0 1 0 1])\n               ]\n           (set-colour colour-result)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))\n     im)))&quot; &quot;(defn set-colour [^Vector4 colour-result]\n       (.set colour-result 1 1.0))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ x res-x) (/ y res-y)))]\n           (set-colour colour-result)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n           )))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (set-colour colour-result)\n           (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n           )))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n               (set-colour colour-result)\n               )))))\n     im)))&quot; &quot;(defn set-colour [^Vector4 colour-result pixel-intensity]\n       (.set colour-result 1 pixel-intensity))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (set-colour colour-result pixel-intensity)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (set-colour colour-result)\n               ;(.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (set-colour colour-result 0)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn set-colour [^Vector4 colour-result x]\n       (.set colour-result 1 (rand)))&quot; &quot;(defn set-colour [^Vector4 colour-result x]\n       (.set colour-result 1 x))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (set-colour colour-result 1)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn set-colour [^Vector4 colour-result]\n       (.set colour-result 1 (rand)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (set-colour colour-result)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.set colour-result 1 (rand)))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.set colour-result 1 1)\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   colour-result (v/vec4 [0.5 0 0.8 1])\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               ; (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n\n               )))))\n     im)))&quot; &quot;(defn render\n  \&quot;Render a scene to a new bufferedimage\&quot;\n  (^BufferedImage [&amp; {:keys [width height]\n                      :or   {width 500 height 500}}]\n   (let [width (int width)\n         height (int height)\n         colour-result (v/vec4 [0.5 0 0.8 1])\n         ^BufferedImage im (new-image width height)]\n     (dotimes [ix width]\n       (dotimes [iy height]\n         (let [plane-intersection (ray-plane camera-location (camera-ray (/ ix res-x) (/ iy res-y)))]\n           (if plane-intersection\n             (let [u-tex (mget plane-intersection 0)\n                   v-tex (mget plane-intersection 2)\n                   pixel-intensity (int (checker-texture u-tex v-tex 1))]\n               (.set colour-result 1 (rand))\n               (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n     im)))&quot; &quot;(time (show))&quot; &quot;\n(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 300 300)]\n  (view image))\n\n(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.85)\n             (sphere (v3d 250 200 -600) 400 0.85)\n             (sphere (v3d 200 100 -600) 400 0.65)\n             ]\n      image (ray-trace world eye 300 300)]\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.8)]\n      image (ray-trace world eye 300 300)]\n\n  (view image))&quot; &quot;(let [eye (v3d 150 150 200)\n      world [(sphere (v3d 150 150 -600) 400 0.85)\n             (sphere (v3d 250 200 -600) 400 0.85)\n             (sphere (v3d 200 100 -600) 400 0.65)\n             ]\n      image (ray-trace world eye 300 300)]\n  (view image))&quot;], :remote []}}</component>
</project>

