<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1416114958599">{:repl-history {:ide [], :local [&quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 1 0])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n\n        sphere-surface (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                           :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                           :phong-exponent 5})\n\n        my-sphere (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 0.5 3]) :radius 1.5 :surface sphere-surface})\n\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              {:keys [sphere-intersection normal]} (intersect my-sphere ray)]\n          (if sphere-intersection\n            (let [\n                  eye-direction (- (:P1 ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface my-sphere) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(time (image/show (render-spher2) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-sphere2) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(def mat (array [[1 2 3] [4 5 6] [7 8 9]]))&quot; &quot;mat&quot; &quot;(def mat (array [[1 0 0] [0 1 0] [0 0 1]]))&quot; &quot;(m/determinant mat)&quot; &quot;(m/determinant (array [[1 0 0] [0 1 0] [0 0 1]]))&quot; &quot;(m/determinant (array [[2 0 0] [0 1 0] [0 0 1]]))&quot; &quot;(def u (array [1 0 0]))&quot; &quot;(def v (array [0 1 0]))&quot; &quot;u&quot; &quot;v&quot; &quot;(def A (array u u u))&quot; &quot;(def A (array v v v))&quot; &quot;(def A (array [u u u]))&quot; &quot;(def A (array [u v v]))&quot; &quot;(def u (v/vec3 [1 0 0]))&quot; &quot;(def v (v/vec3 [0 1 0]))&quot; &quot;(def n (v/vec3 [0 0 1]))&quot; &quot;(def A (array [u v n]))&quot; &quot;A&quot; &quot;(m/transpose A)&quot; &quot;(m/determinant A)&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])])\n    ))&quot; &quot;(def my-plane (map-&gt;Plane {:point 0 :u-axis 0 :v-axis 0}))&quot; &quot;(def my-plane (map-&gt;Plane {:point (v/vec [0 0 0]):u-axis 0 :v-axis 0}))&quot; &quot;(def my-plane (map-&gt;Plane {:point (v/vec [0 0 0])\n                           :u-axis (v/vec [1 0 0])\n                           :v-axis (v/vec [0 0 1])}))&quot; &quot;(def my-ray (map-&gt;Ray {:ray-origin (v/vec [0 0 0])\n                       :ray-direction (v/vec [1 1 1])}))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])]\n      (print \&quot;test\&quot;)\n      )))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])]\n      1\n      )))&quot; &quot;my-plane&quot; &quot;my-ray&quot; &quot;(intersect 1 1)&quot; &quot;(intersect my-plane 1)&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])]\n      ))\n  1\n  )&quot; &quot;(defrecord Camera [camera-location camera-direction camera-x camera-y])&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;test\&quot;)\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])]\n      )))&quot; &quot;(def sphere-surface0\n  (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                      :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                      :phong-exponent 50}))&quot; &quot;(defrecord Sphere [center radius surface]\n  SceneObject\n  (intersect\n    [this ray]\n    (print \&quot;intersecting ray with sphere\\n\&quot;)\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          C center\n          r radius]\n      (v/normalise! P1)\n      (let [a (v/dot P1 P1)\n            b (* 2 (v/dot P1 (- P0 C)))\n            c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n            det (- (* b b) (* 4 a c))\n            hit (pos? det)\n            t (if hit (/ (- 0 b (math/sqrt (- (* b b) (* 4 a c)))) (* 2 a)))\n            intersection (if hit (+ P0 (* t P1)))\n            normal (if intersection (v/normalise (- intersection C)))\n            distance (if intersection (v/distance P0 intersection))]\n        {:scene-object this :sphere-intersection intersection :normal normal :distance distance}))))&quot; &quot;(def my-sphere0\n  (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0}))&quot; &quot;(intersect my-sphere0 my-ray)&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;test\&quot;)\n    ;(let [P1 (:ray-direction ray)\n    ;      M (array [u-axis v-axis (- P1)])]\n    ;  )\n    ))&quot; &quot;(def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                           :u-axis (v/vec [1 0 0])\n                           :v-axis (v/vec [0 0 1])}))&quot; &quot;(intersect my-plane my-ray)&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;intersecting ray with plane\&quot;)\n    ;(let [P1 (:ray-direction ray)\n    ;      M (array [u-axis v-axis (- P1)])]\n    ;  )\n    ))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])]\n      (print \&quot;intersecting ray with plane\&quot;))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])]\n      (print \&quot;intersecting ray with plane\&quot;)\n      1)))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (print \&quot;intersecting ray with plane\&quot;)\n      (if det 1 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (print det)\n      (if det 1 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (print det)\n      (if-not (zero? det) 1 0))))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 0])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 0])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 2 0])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 1])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 2])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 2 2])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 1 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 2 2])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 1])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 2 2])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 1])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 2])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        scene-objects [my-sphere0                           ; my-sphere1 my-sphere2\n                       ]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (vec (repeat (count scene-objects) ray))\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:sphere-intersection closest-intersection)\n            (let [\n                  sphere-intersection (:sphere-intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          b (if-not (zero? det) (m/inverse M))\n          det (m/determinant M)]\n      (if-not (zero? det) b 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) (m/inverse M))]\n      (if-not (zero? det) b 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          ;b (if-not (zero? det) (m/inverse M))\n          ]\n      (if-not (zero? det) 1 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) (m/inverse M))\n          ]\n      (if-not (zero? det) 1 0))))&quot; &quot;(m/inverse (array [[1 0 0] [0 1 0] [0 0 1]]))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) (m/inverse (array [[1 0 0] [0 1 0] [0 0 1]])))\n          ]\n      (if-not (zero? det) 1 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n;          b (if-not (zero? det) (m/inverse (array [[1 0 0] [0 1 0] [0 0 1]])))\n          ]\n      (if-not (zero? det) 1 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) (m/inverse (array [[1 0 0] [0 1 0] [0 0 1]])) 0)\n          ]\n      (if-not (zero? det) 1 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) 1 0)\n          ]\n      (if-not (zero? det) (m/inverse (array [[1 0 0] [0 1 0] [0 0 1]])) 0))))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 1])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [5 0 2])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) 1 0)\n          ]\n      (if-not (zero? det) 1 0))))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 ])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) 1 0)\n          ]\n      (if-not (zero? det) (m/inverse (array [[1 0 0] [0 10 0] [0 0 1]])) 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          MM (array [u-axis v-axis (- P1)])\n          det (m/determinant MM)\n          b (if-not (zero? det) (m/inverse MM) 0)\n          ]\n      (if-not (zero? det) (m/inverse (array [[1 0 0] [0 10 0] [0 0 1]])) 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)\n          b (if-not (zero? det) (m/inverse M) 0)\n          ]\n      (if-not (zero? det) (m/inverse (array [[1 0 0] [0 10 0] [0 0 1]])) 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (if-not (zero? det) 1 0))))&quot; &quot;(time (image/show (render-spheres) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(m/inverse (array [[1 0 0] [0 10 0] [0 0 1]]))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (if-not (zero? det) (array [[1 0 0] [0 10 0] [0 0 1]]) 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (if-not (zero? det) (m/inverse (array [[1 0 0] [0 10 0] [0 0 1]])) 0))))&quot; &quot;(defrecord Plane [point u-axis v-axis]\n  SceneObject\n  (intersect [this ray]\n    (let [P1 (:ray-direction ray)\n          M (array [u-axis v-axis (- P1)])\n          det (m/determinant M)]\n      (if-not (zero? det) (m/inverse M) 0))))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n\n  (intersect my-plane my-ray))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n  \n  \n  (intersect my-plane my-ray0))&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n  \n  \n  (intersect my-plane my-ray0)\n  (intersect my-plane my-ray1)\n  )&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n\n\n  (print (intersect my-plane my-ray0)\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n\n\n  (print (intersect my-plane my-ray0 \&quot;\\n\\n\&quot;)\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                         :ray-direction (v/vec [1 1 1])}))\n\n\n  (print (intersect my-plane my-ray0)\n         \&quot;\\n\\n\&quot;\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n\n  (print \&quot;\\n\\n\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n\&quot;\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) (m/inverse M) 0))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1))\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) (m/inverse M) 0))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) \n          (let [M-inv (m/inverse M)]))\n        M-inv        \n        )))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            M-inv (if-not (zero? det) (m/inverse M) 0)]\n        M-inv)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            M-inv (if-not (zero? det) (m/inverse M) 0)]\n        1)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)]\n        (if-not (zero? det) (m/inverse M) 0))))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) 1 0)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) (m/inverse M) 0)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) 1)]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P1 (:ray-direction ray)\n            M (array [u-axis v-axis (- P1)])\n            det (m/determinant M)\n            tmp (if-not (zero? det) (m/inverse M))]\n        (if-not (zero? det) (m/inverse M) 0)\n        tmp)))\n\n  (def my-plane (map-&gt;Plane {:point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot;], :remote []}}</component>
</project>

