<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1415630735243">{:repl-history {:ide [], :local [&quot;(let [^Vector3 camera-location (array [0 1 0])\n      ^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 1 -3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  sphere-intersection\n  )&quot; &quot;(let [^Vector3 camera-location (array [0 1 0])\n      ^Vector3 camera-direction (v/vec3 [0 0 1])\n      ^Vector3 sphere-origin (v/vec3 [0 -1 -3])\n      sphere-radius 1.0\n      sphere-intersection (ray-sphere camera-location dir sphere-origin sphere-radius)]\n  sphere-intersection\n  )&quot; &quot;P0&quot; &quot;(def P0 (v/vec3 [0 0 0]))&quot; &quot;(def P1 (v/vec3 [0 0 1]))&quot; &quot;(def C (v/vec3 [0 0 3]))&quot; &quot;(def r 1)&quot; &quot;(def det (- (* b b) (* 4 a c)))&quot; &quot;(def C (v/vec3 [0 3 3]))&quot; &quot;(def a (v/dot P1 P1))&quot; &quot;a&quot; &quot;(def b (* 2 (v/dot P1 (- P0 C))))&quot; &quot;b&quot; &quot;(def c (- (v/dot (- P0 C) (- P0 C)) (* r r)))&quot; &quot;c&quot; &quot;(def det2 (- (* b b) (* 4 a c)))&quot; &quot;det2&quot; &quot;(if -1 true false)&quot; &quot;(defn render-plane-and-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-hit sphere-intersection]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if (and sphere-intersection plane-intersection)\n            (let [plane-distance (v/magnitude (- plane-intersection camera-location))\n                  sphere-distance (v/magnitude (- sphere-intersection camera-location))\n                  pixel-intensity (if (&lt; sphere-distance plane-distance) 1.0 0.0)]\n              ;(.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setValues colour-result pixel-intensity 0 0 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(inf)&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [plane-intersection (ray-plane sphere-intersection normal)]\n              (let [pixel-intensity (if plane-intersection\n                                      (let [u-tex (mget plane-intersection 0)\n                                            v-tex (mget plane-intersection 2)\n                                            pixel-intensity (+ (checker-texture u-tex v-tex 1) (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n                                        pixel-intensity\n                                        )\n                                      (+  (/ (math/expt (- (v/mget normal 2)) 0) 1.5) (/ (- (v/mget normal 2)) 3)))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))))\n    im))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [plane-intersection2 (ray-plane sphere-intersection normal)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (checker-texture u-tex v-tex 1) (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n                                        pixel-intensity\n                                        )\n                                      (+  (/ (math/expt (- (v/mget normal 2)) 0) 1.5) (/ (- (v/mget normal 2)) 3)))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            \n            ))))\n    im))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 1 3])\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [plane-intersection2 (ray-plane sphere-intersection normal)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (checker-texture u-tex v-tex 1) (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n                                        pixel-intensity\n                                        )\n                                      (+ (/ (math/expt (- (v/mget normal 2)) 0) 1.5) (/ (- (v/mget normal 2)) 3)))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 1)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))))\n    im))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 0.2 0])\n        ^Vector3 camera-direction (v/vec3 [1 0 1])\n        ^Vector3 camera-x (v/vec3 [0.5 0 -0.5])\n        ^Vector3 camera-y (v/vec3 [0 0.707 0])\n        ^Vector3 sphere-origin (v/vec3 [3 1 3])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 1 -2]))\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (+ (* 1 (rand)) (double ix)) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (+ (* 1 (rand)) (double iy)) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [reflected-direction (- dir (* 2 (dot dir normal) normal))\n                  plane-intersection2 (ray-plane sphere-intersection reflected-direction)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (* 0.5 (checker-texture u-tex v-tex 1))\n                                                               (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 50))\n                                                                  (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 5))\n                                                                  ))]\n                                        pixel-intensity)\n                                      (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 50))\n                                         (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 5))))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 2)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n              (let [pixel-intensity 0.0]\n                (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n                ))))))\n    im)\n\n\n\n  ;(time (image/show (render-plane-and-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  ;(time (image/show (render-plane) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  ;(time (image/show (render-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;)))&quot; &quot;(+ 1 1)&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 0.2 0])\n        ^Vector3 camera-direction (v/vec3 [1 0 1])\n        ^Vector3 camera-x (v/vec3 [0.5 0 -0.5])\n        ^Vector3 camera-y (v/vec3 [0 0.707 0])\n        ^Vector3 sphere-origin (v/vec3 [3 1 3])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 1 -2]))\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (+ (* 1 (rand)) (double ix)) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (+ (* 1 (rand)) (double iy)) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [reflected-direction (- dir (* 2 (dot dir normal) normal))\n                  plane-intersection2 (ray-plane sphere-intersection reflected-direction)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (* 0.5 (checker-texture u-tex v-tex 1))\n                                                               (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 50))\n                                                                  (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 5))\n                                                                  ))]\n                                        pixel-intensity)\n                                      (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 50))\n                                         (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 5))))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 2)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n              (let [pixel-intensity 0.0]\n                (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n                ))))))\n    im)\n\n\n\n  (time (image/show (render-plane-and-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-plane) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))\n  (time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;)))&quot; &quot;(time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn render-reflective-sphere []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 0.2 0])\n        ^Vector3 camera-direction (v/vec3 [1 0 1])\n        ^Vector3 camera-x (v/vec3 [0.5 0 -0.5])\n        ^Vector3 camera-y (v/vec3 [0 0.707 0])\n        ^Vector3 sphere-origin (v/vec3 [3 1 3])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 1 -2]))\n        sphere-radius 1\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (+ (* 1 (rand)) (double ix)) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (+ (* 1 (rand)) (double iy)) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (ray-sphere camera-location dir sphere-origin sphere-radius)\n              plane-intersection (ray-plane camera-location dir)]\n          (if sphere-intersection\n            (let [reflected-direction (- dir (* 2 (dot dir normal) normal))\n                  plane-intersection2 (ray-plane sphere-intersection reflected-direction)]\n              (let [pixel-intensity (if plane-intersection2\n                                      (let [u-tex (mget plane-intersection2 0)\n                                            v-tex (mget plane-intersection2 2)\n                                            pixel-intensity (+ (* 0.5 (checker-texture u-tex v-tex 1))\n                                                               (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 50))\n                                                                  (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal\n                                                                                                             (v/vec3\n                                                                                                               light-direction)))) 5))\n                                                                  ))]\n                                        pixel-intensity)\n                                      (+ (* 0.5 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 50))\n                                         (* 0.3 (math/expt (Math/sin (* pi 0.5 (dot normal (v/vec3 light-direction)))\n                                                                     ) 5))))]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))))\n            (if plane-intersection\n              (let [u-tex (mget plane-intersection 0)\n                    v-tex (mget plane-intersection 2)\n                    pixel-intensity (checker-texture u-tex v-tex 2)\n                    ]\n                (.setValues colour-result ^double pixel-intensity ^double pixel-intensity ^double pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result)))\n              (let [pixel-intensity 0.0]\n                (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n                (.setRGB im ix iy (c/argb-from-vector4 colour-result))\n                ))))))\n    im)\n\n\n\n  (time (image/show (render-reflective-sphere) :zoom (/ 500 res-x) :title \&quot;Isn't it beautiful?\&quot;)))&quot; &quot;(render-reflective-sphere)&quot; &quot;(ray-sphere)&quot; &quot;(time (image/show (render-reflective-sphere) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-sphere) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defprotocol SceneObject\n  (intersect [this ray]))&quot; &quot;(defrecord Sphere [center radius]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;intersecting with sphere\&quot;)\n    ))&quot; &quot;(defrecord Plane [point normal]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;intersecting with plane\&quot;)\n    ))&quot; &quot;(-&gt;Sphere [0 0 0] 0.5)&quot; &quot;(Sphere. [0 0 0] 0.5)&quot; &quot;(let [ray [0 0 1]\n      my-sphere (-&gt;Sphere [0 0 0] 0.5)]\n  (intersect my-sphere ray))&quot; &quot;(let [ray [0 0 1]\n      my-plane (-&gt;Plane [0 0 0] [0 1 0])]\n  (intersect my-plane ray))&quot; &quot;(let [my-ray (ray 1 2)]\n  (:P0 my-ray))&quot; &quot;(defn ray [^v/vec3 P0 ^v/vec3 P1] {:P0 P0 :P1 P1})&quot; &quot;(defn ray [^int P0 ^int P1] {:P0 P0 :P1 P1})&quot; &quot;(defn ray [^float P0 ^float P1] {:P0 P0 :P1 P1})&quot; &quot;(ns ray.defprotocol-test\n  (:require [mikera.vectorz.core :as v]))&quot; &quot;(defn ray [P0 P1] {:pre [(v/vec3? P0)]} {:P0 P0 :P1 P1})&quot; &quot;(let [my-ray (ray (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (my-ray.P0))&quot; &quot;(defn ray [^long P0 ^long P1] {:P0 P0 :P1 P1})&quot; &quot;(let [my-ray (ray (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (:P0 my-ray))&quot; &quot;(defn ray [^long P0 ^v/vec3 P1] {:P0 P0 :P1 P1})&quot; &quot;(defn ray [^int P0 P1] {:P0 P0 :P1 P1})&quot; &quot;(defn ray [^double P0 P1] {:P0 P0 :P1 P1})&quot; &quot;(defn ray [P0 P1] {:P0 P0 :P1 P1})&quot; &quot;(defrecord ray :P0 :P1)&quot; &quot;(defrecord ray [P0 P1])&quot; &quot;(let [my-ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  )&quot; &quot;(let [my-ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  my-ray.P0\n  )&quot; &quot;(let [my-ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (my-ray/P0))&quot; &quot;(defrecord Ray [^v/vec3 P0 ^v/vec3 P1])&quot; &quot;(defrecord Ray [P0 P1])&quot; &quot;(let [my-ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (:P0 my-ray))&quot; &quot;(let [my-ray (-&gt;Ray (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (:P0 my-ray))&quot; &quot;(let [my-ray (.Ray (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (:P0 my-ray))&quot; &quot;(let [my-ray (Ray. (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))]\n  (:P0 my-ray))&quot; &quot;(defrecord Plane [point ^float normal]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;intersecting ray with plane\\n\&quot;)\n    ))&quot; &quot;(let [ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))\n      my-plane (Plane. [0 0 0] [0 1 0])]\n  (intersect my-plane ray))&quot; &quot;(defrecord Sphere [center radius]\n  SceneObject\n  (intersect [this ray]\n    (print \&quot;intersecting ray with sphere\\n\&quot;)\n    (let [P0 (:P0 ray)\n          P1 (:P1 ray)\n          C center\n          r radius]\n      (v/normalise! P1)\n      (let [a (v/dot P1 P1)\n            b (* 2 (v/dot P1 (- P0 C)))\n            c (- (v/dot (- P0 C) (- P0 C)) (* r r))\n            det (- (* b b) (* 4 a c))\n            hit (pos? det)\n            [intersection normal] (if hit (let [t (/ (- 0 b (math/sqrt (- (* b b) (* 4 a c)))) (* 2 a))\n                                                intersection (+ P0 (* t P1))\n                                                normal (v/normalise (- intersection C))]\n                                            [intersection normal]))]\n        {:sphere-intersection intersection :normal normal}))))&quot; &quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 1 0])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0.5 3])\n        sphere-radius 1.5\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (intersect [(Sphere sphere-origin sphere-radius) (Ray camera-location dir)])]\n          (if sphere-intersection\n            (let [pixel-intensity (+ (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 1 0])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0.5 3])\n        sphere-radius 1.5\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n        (let [{:keys [sphere-intersection normal]} (intersect (Sphere sphere-origin sphere-radius) (Ray camera-location dir))]\n          (if sphere-intersection\n            (let [pixel-intensity (+ (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 1 0])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0.5 3])\n        sphere-radius 1.5\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (Sphere sphere-origin sphere-radius)\n        (let [{:keys [sphere-intersection normal]} (intersect (Sphere sphere-origin sphere-radius) (Ray camera-location dir))]\n          (if sphere-intersection\n            (let [pixel-intensity (+ (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 1 0])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0.5 3])\n        sphere-radius 1.5\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (Sphere sphere-origin sphere-radius)\n        (Ray camera-location dir)\n        (let [{:keys [sphere-intersection normal]} (intersect (Sphere sphere-origin sphere-radius) (Ray camera-location dir))]\n          (if sphere-intersection\n            (let [pixel-intensity (+ (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(intersect (Sphere (v/vec3 [0 0 1]) 1) (Ray (v/vec3 [0 0 0]) (v/vec3 [0 1 0])))&quot; &quot;(let [ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))\n      my-sphere (Sphere. [0 0 0] 0.5)]\n  (intersect my-sphere (Ray (v/vec3 [0 0 0]) (v/vec3 [0 1 0]))))&quot; &quot;(let [ray (Ray.  (v/vec3 [0 0 0]) (v/vec3 [0 0 1]))\n      my-sphere (Sphere. [0 0 0] 0.5)]\n  (intersect my-sphere ray))&quot; &quot;(intersect (Sphere. (v/vec3 [0 0 1]) 1) (Ray. (v/vec3 [0 0 0]) (v/vec3 [0 1 0])))&quot; &quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 camera-location (v/vec3 [0 1 0])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        ^Vector3 sphere-origin (v/vec3 [0 0.5 3])\n        sphere-radius 1.5\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (.set dir camera-direction)\n        (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        (v/normalise! dir)\n\n        (let [{:keys [sphere-intersection normal]} (intersect (Sphere. sphere-origin sphere-radius) (Ray. camera-location dir))]\n          (if sphere-intersection\n            (let [pixel-intensity (+ (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn camera-ray\n  \&quot;x and y are coordinates from 0 to 1, starting at the top left of the image\&quot;\n  [x y]\n  (let [camera-direction (v/vec3 [0 0 1])\n        camera-x (v/vec3 [1 0 0])\n        camera-y (v/vec3 [0 1 0])]\n    (+ (* 2 (- x 0.5) camera-x) (* -2 (- y 0.5) camera-y) camera-direction))\n  )&quot; &quot;(defn camera-ray2\n  \&quot;x and y are coordinates from 0 to 1, starting at the top left of the image\&quot;\n  [x y camera-direction camera-x camera-y]\n  (.set dir camera-direction)\n  (v/add-multiple! dir camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n  (v/add-multiple! dir camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n  (v/normalise! dir))&quot; &quot;(defn checker-texture [x y checker-spacing]\n  (let [xs (math/round (/ (mod x checker-spacing) checker-spacing))\n        ys (math/round (/ (mod y checker-spacing) checker-spacing))]\n    (* 0.7 (mod (+ xs ys) 2.0))))&quot; &quot;(def v1 v/vec3 [0 0 1])&quot; &quot;(def v1 (v/vec3) [0 0 1])&quot; &quot;(def v1 (v/vec3 [0 0 1]))&quot; &quot;(def v2 (v/vec3 [0 1 0]))&quot; &quot;(v/add v1 v2)&quot; &quot;(v/addmultiple v1 v2 2)&quot; &quot;(v/addmultiple! v1 v2 2)&quot; &quot;(v/add-multiple v1 v2 2)&quot; &quot;v2&quot; &quot;(defn camera-ray2\n  \&quot;x and y are coordinates from 0 to 1, starting at the top left of the image\&quot;\n  [x y camera-direction camera-x camera-y]\n  (let [temp1 (v/add-multiple camera-direction camera-x (* 2 (- (/ (double ix) res-x) 0.5)))\n        temp2 (v/add-multiple temp1 camera-y (* -2 (- (/ (double iy) res-y) 0.5)))\n        temp3 (v/normalise temp2)]\n    temp3))&quot; &quot;(defrecord Camera [camera-location camera-direction camera-x camera-y])&quot; &quot;(defn render-sphere2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 camera-location (v/vec3 [0 1 0])\n        ^Vector3 camera-direction (v/vec3 [0 0 1])\n        ^Vector3 camera-x (v/vec3 [1 0 0])\n        ^Vector3 camera-y (v/vec3 [0 1 0])\n        my-camera (Camera. [camera-location camera-direction camera-x camera-y])\n\n        ^Vector3 sphere-origin (v/vec3 [0 0.5 3])\n        sphere-radius 1.5\n        my-sphere (Sphere. sphere-origin sphere-radius)\n\n        ;MUTABLES\n        ^Vector3 dir (v/vec3 [0 0 0])\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [camera-direction (camera-ray ix iy camera-direction camera-x camera-y)\n              ray (Ray. camera-location camera-direction)\n              {:keys [sphere-intersection normal]} (intersect my-sphere ray)]\n          (if sphere-intersection\n            (let [pixel-intensity (+ (/ (math/expt (- (v/mget normal 2)) 30) 1.5) (/ (- (v/mget normal 2)) 3))]\n              (.setValues colour-result pixel-intensity pixel-intensity pixel-intensity 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defrecord Camera [camera-location camera-direction camera-x camera-y]\n  (camera-ray [this x y]\n    (print \&quot;camera-ray\&quot;)))&quot; &quot;(defrecord Camera [camera-location camera-direction camera-x camera-y]\n  SceneObject\n  (camera-ray [this x y]\n    (print \&quot;camera-ray\&quot;)))&quot; &quot;(defrecord Camera [camera-location camera-direction camera-x camera-y]\n  SceneObject\n  (test-func [this x y]\n    (print \&quot;camera-ray\&quot;)))&quot; &quot;(defrecord Camera [camera-location camera-direction camera-x camera-y]\n  (test-func [this x y]\n    (print \&quot;camera-ray\&quot;)))&quot; &quot;(defprotocol Camera\n  (test-func [this x y]))&quot; &quot;(defrecord Camera0 [camera-location camera-direction camera-x camera-y]\n  Camera\n  (test-func [this x y]\n    (print \&quot;camera-ray\&quot;)))&quot; &quot;(defrecord Camera0 [camera-location camera-direction camera-x camera-y]\n  Camera\n  (camera-ray [this x y]\n    (print \&quot;camera-ray\&quot;)))&quot; &quot;(defrecord Camera0 [camera-location camera-direction camera-x camera-y]\n  Camera\n  (camera-ray [this x y]\n    (let [camera-direction (:camera-direction this)\n          camera-x (:camera-x this)\n          camera-y (:camera-y this)]\n      (+ (* 2 (- (/ (+ (rand) (double ix)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double iy)) res-y) 0.5) camera-y) camera-direction))))&quot; &quot;(defprotocol Camera\n  (camera-ray [this x y]))&quot; &quot;(defrecord Camera0 [camera-location camera-direction camera-x camera-y]\n  Camera\n  (camera-ray [this x y]\n    (let [camera-direction (:camera-direction this)\n          camera-x (:camera-x this)\n          camera-y (:camera-y this)]\n      (+ (* 2 (- (/ (+ (rand) (double x)) res-x) 0.5) camera-x) (* -2 (- (/ (+ (rand) (double y)) res-y) 0.5) camera-y) camera-direction))))&quot; &quot;(time (image/show (render-sphere2) :title \&quot;Isn't it beautiful?\&quot;))&quot;], :remote []}}</component>
</project>

