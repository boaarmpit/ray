<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1416751790462">{:repl-history {:ide [], :local [&quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [1 1 0])\n                          :ray-direction (v/vec [2 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [0 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 0])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 0 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 2 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                              :u-axis (v/vec [1 0 0])\n                              :v-axis (v/vec [0 0 1])})\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:sphere-intersection closest-intersection)\n            (let [\n                  sphere-intersection (:sphere-intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t-coord (v/get b 2)\n                ]\n           {:u-coord u-coord :v-coord v-coord :t-coord t-coord})))))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (:ray-direction ray)\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n                \n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n  \n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product u-axis v-axis)}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! u-axis v-axis)}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection\n            :u-coord u-coord :v-coord v-coord :distance t})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                plane-intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :plane-intersection plane-intersection :normal normal :distance t\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :sphere-intersection intersection :normal normal :distance distance}\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal surface]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :intersection intersection :normal normal :distance t\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                      :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                      :phong-exponent 50})\n  \n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal surface]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans  (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                intersection (+ P0 (* t P1))\n\n                ]\n           {:scene-object this :intersection intersection :normal normal :distance t\n            :u-coord u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  (def plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                         :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                         :phong-exponent 50}))\n\n  (def my-plane (map-&gt;Plane {:plane-point  (v/vec [0 0 0])\n                             :u-axis (v/vec [1 0 0])\n                             :v-axis (v/vec [0 0 1])\n                             :normal (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(do\n\n  (defrecord Plane [plane-point u-axis v-axis normal surface]\n    SceneObject\n    (intersect [this ray]\n      (let [P0 (:ray-origin ray)\n            P1 (v/normalise (:ray-direction ray))\n            M-trans (array [u-axis v-axis (- P1)])\n            det (m/determinant M-trans)\n            ;M-inv (if-not (zero? det) (m/inverse M-trans))\n            ;b (if M-inv (* M-inv (- P0 plane-point)))\n            ]\n        ;        (print \&quot;P0:\&quot; P0 \&quot;\\nP1\&quot; P1 \&quot;\\nM\&quot; M-trans \&quot;\\n\\n\&quot;)\n        (if-not (zero? det)\n          (let [M (m/transpose M-trans)\n                M-inv (m/inverse M)\n                b (mmul M-inv (- P0 plane-point))\n                u-coord (v/get b 0)\n                v-coord (v/get b 1)\n                t (v/get b 2)\n                intersection (if (pos? t) (+ P0 (* t P1)))\n                distance (if (pos? t) t)\n\n                ]\n            {:scene-object this :intersection intersection :normal normal :distance distance\n             :u-coord      u-coord :v-coord v-coord})))))\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  (def plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                         :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                         :phong-exponent 50}))\n\n  (def my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                             :u-axis      (v/vec [1 0 0])\n                             :v-axis      (v/vec [0 0 1])\n                             :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface     plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 -0.5 0])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 0 1])\n                              :normal      (v/vec [0 1 0])          ;(v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 1.7 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 -0.5 0])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 0 1])\n                              :normal      (v/vec [0 1 0])          ;(v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 (math/sqrt 5.5)])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot; my-plane&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 50})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 (math/sqrt 5.5)])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans (array [u-axis v-axis (- P1)])\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          ;det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans (array) [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n      (print M-trans)\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans (array [u-axis v-axis (- P1)])\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              M (m/transpose M-trans)\n              M-inv (m/inverse M)\n              b (mmul M-inv (- P0 plane-point))\n              u-coord (v/get b 0)\n              v-coord (v/get b 1)\n              t (v/get b 2)\n              hit (pos? t)\n              intersection (if hit (+ P0 (* t P1)))\n              distance (if hit t)\n\n              ;u-coord 0\n              ;v-coord 0\n              ;intersection 0                                ;(v/vec3 [0 0 0])\n              ;distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          ;det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              ;M (m/transpose M-trans)\n              ;M-inv (m/inverse M)\n              ;b (mmul M-inv (- P0 plane-point))\n              ;u-coord (v/get b 0)\n              ;v-coord (v/get b 1)\n              ;t (v/get b 2)\n              ;hit (pos? t)\n              ;intersection (if hit (+ P0 (* t P1)))\n              ;distance (if hit t)\n\n              u-coord 0\n              v-coord 0\n              intersection 0                                ;(v/vec3 [0 0 0])\n              distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det 1                                             ; (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              ;M (m/transpose M-trans)\n              ;M-inv (m/inverse M)\n              ;b (mmul M-inv (- P0 plane-point))\n              ;u-coord (v/get b 0)\n              ;v-coord (v/get b 1)\n              ;t (v/get b 2)\n              ;hit (pos? t)\n              ;intersection (if hit (+ P0 (* t P1)))\n              ;distance (if hit t)\n\n              u-coord 0\n              v-coord 0\n              intersection 0                                ;(v/vec3 [0 0 0])\n              distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(do\n\n\n\n  ;{:scene-object this :intersection intersection :normal normal :distance distance}\n\n  (def plane-surface (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                         :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                         :phong-exponent 50}))\n\n  (def my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                             :u-axis      (v/vec [1 0 0])\n                             :v-axis      (v/vec [0 0 1])\n                             :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))\n                             :surface     plane-surface}))\n\n  (def my-ray0 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 -1 1])}))\n\n  (def my-ray1 (map-&gt;Ray {:ray-origin    (v/vec [0 1 0])\n                          :ray-direction (v/vec [1 0 1])}))\n\n\n  (print \&quot;\\n\\n hit:\&quot;\n         (intersect my-plane my-ray0)\n         \&quot;\\n\\n miss:\&quot;\n         (intersect my-plane my-ray1)\n         \&quot;\\n\\n\&quot;)\n  )&quot; &quot;(defrecord Plane [plane-point u-axis v-axis normal surface]\n  SceneObject\n  (intersect [this ray]\n    (let [P0 (:ray-origin ray)\n          P1 (:ray-direction ray)\n          M-trans [u-axis v-axis (- P1)]\n          det (m/determinant M-trans)\n          ;M-inv (if-not (zero? det) (m/inverse M-trans)) this gives an error\n          ;b (if M-inv (* M-inv (- P0 plane-point)))\n          ]\n\n      (if-not (zero? det)\n        (let [\n\n              ;M (m/transpose M-trans)\n              ;M-inv (m/inverse M)\n              ;b (mmul M-inv (- P0 plane-point))\n              ;u-coord (v/get b 0)\n              ;v-coord (v/get b 1)\n              ;t (v/get b 2)\n              ;hit (pos? t)\n              ;intersection (if hit (+ P0 (* t P1)))\n              ;distance (if hit t)\n\n              u-coord 0\n              v-coord 0\n              intersection 0                                ;(v/vec3 [0 0 0])\n              distance 0\n\n              ]\n          {:scene-object this :intersection intersection :normal normal :distance distance\n           :u-coord      u-coord :v-coord v-coord})))))&quot; &quot;(defn render-spheres []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5})\n\n        my-plane (map-&gt;Plane {:plane-point (v/vec [0 0 (math/sqrt 5.5)])\n                              :u-axis      (v/vec [1 0 0])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [1 0 0]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane]\n\n        ^BufferedImage im (new-image res-x res-y)]\n\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))\n              rays (repeat (count scene-objects) ray)\n              intersections (map intersect scene-objects rays)\n              closest-intersection (reduce closest intersections)\n              ]\n\n          (if (:intersection closest-intersection)\n            (let [\n                  ;intersection (:intersection closest-intersection)\n                  scene-object (:scene-object closest-intersection)\n                  normal (:normal closest-intersection)\n                  eye-direction (- (:ray-direction ray))\n                  ^Vector3 pixel-colour (surface-colour (:surface scene-object) {:normal normal :light-direction light-direction :eye-direction eye-direction})\n                  pixel-r (v/get pixel-colour 0)\n                  pixel-g (v/get pixel-colour 1)\n                  pixel-b (v/get pixel-colour 2)]\n              ;MUTATING colour-result and im\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -2])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1.2 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1.2 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1.2 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5\n                                          :reflectivity   1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [1 0 0])\n                              :u-axis      (v/vec [0 0 1])\n                              :v-axis      (v/vec [0 1 0])\n                              :normal      (v/cross-product! (v/vec [0 0 1]) (v/vec [0 1 0]))\n                              :surface     plane-surface})\n        my-plane1 (map-&gt;Plane {:plane-point (v/vec [-1 0 0])\n                              :u-axis      (v/vec [0 1 0])\n                              :v-axis      (v/vec [0 0 1])\n                              :normal      (v/cross-product! (v/vec [0 1 0]) (v/vec [0 0 1]))\n                              :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane0 my-plane1]\n\n        ^BufferedImage im (new-image res-x res-y)]\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))]\n          (if-let [traced-ray (trace-ray ray scene-objects light-direction)]\n            (let [\n                  reflected-ray (:reflected-ray traced-ray)\n                  pixel-colour (if reflected-ray (:pixel-colour (trace-ray reflected-ray scene-objects light-direction)) (:pixel-colour traced-ray))\n\n                  pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                  pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                  pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n              ;MUTATING colour-result and im\n\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1]))&quot; &quot;(defn trace-ray [ray scene-objects light-direction reflection-depth]\n  (let [rays (repeat (count scene-objects) ray)\n        intersections (map intersect scene-objects rays)\n        closest-intersection (reduce closest intersections)]\n    (if (:intersection closest-intersection)\n      (let [\n            intersection (:intersection closest-intersection)\n            scene-object (:scene-object closest-intersection)\n            normal (:normal closest-intersection)\n            eye-direction (- (:ray-direction ray))\n            ^Vector3 pixel-colour (surface-colour (:surface scene-object)\n                                                  {:normal normal :light-direction light-direction :eye-direction eye-direction})\n\n            reflected-ray (if (:reflectivity (:surface scene-object)) 1)]\n        {:pixel-colour pixel-colour :reflected-ray (reflect scene-object ray intersection normal)}\n        ))))&quot; &quot;(defn trace-ray [ray scene-objects light-direction reflection-depth]\n  (let [rays (repeat (count scene-objects) ray)\n        intersections (map intersect scene-objects rays)\n        closest-intersection (reduce closest intersections)]\n    (if (:intersection closest-intersection)\n      (let [\n            intersection (:intersection closest-intersection)\n            scene-object (:scene-object closest-intersection)\n            normal (:normal closest-intersection)\n            eye-direction (- (:ray-direction ray))\n\n            reflected-ray (if (:reflectivity (:surface scene-object)) 1)\n\n            ^Vector3 pixel-colour (if reflected-ray (v/vec3 [0 0 0]) (surface-colour (:surface scene-object)\n                                                                      {:normal normal :light-direction light-direction :eye-direction eye-direction}))\n\n            ]\n        {:pixel-colour pixel-colour :reflected-ray (reflect scene-object ray intersection normal)}\n        ))))&quot; &quot;(defn render-spheres2 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -2])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5\n                                          :reflectivity   1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [1 0 0])\n                               :u-axis      (v/vec [0 1 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [0 1 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n        my-plane1 (map-&gt;Plane {:plane-point (v/vec [-1 0 0])\n                               :u-axis      (v/vec [0 0 1])\n                               :v-axis      (v/vec [0 1 0])\n                               :normal      (- (v/cross-product! (v/vec [0 0 1]) (v/vec [0 1 0])))\n                               :surface     plane-surface})\n\n        my-plane2 (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane0 my-plane1 my-plane2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))]\n          (if-let [traced-ray (trace-ray ray scene-objects light-direction 2)]\n            (let [reflected-ray (:reflected-ray traced-ray)\n                  pixel-colour (if reflected-ray (:pixel-colour (trace-ray reflected-ray scene-objects light-direction)) (:pixel-colour traced-ray))\n\n                  pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                  pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                  pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres3 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -2])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5\n                                          :reflectivity   1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [1 0 0])\n                               :u-axis      (v/vec [0 1 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [0 1 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n        my-plane1 (map-&gt;Plane {:plane-point (v/vec [-1 0 0])\n                               :u-axis      (v/vec [0 0 1])\n                               :v-axis      (v/vec [0 1 0])\n                               :normal      (- (v/cross-product! (v/vec [0 0 1]) (v/vec [0 1 0])))\n                               :surface     plane-surface})\n\n        my-plane2 (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane0 my-plane1 my-plane2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))]\n          (if-let [traced-ray (trace-ray ray scene-objects light-direction 2)]\n            (let [reflected-ray (:reflected-ray traced-ray)\n                  pixel-colour (:pixel-colour (trace-ray reflected-ray scene-objects light-direction 1))\n\n                  pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                  pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                  pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;(defn render-spheres3 []\n  (let [colour-result (v/vec4 [0 0 0 1])\n        ^Vector3 light-direction (v/normalise (v/vec3 [-1 -1 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 -2])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5\n                                          :reflectivity   1})\n\n        my-plane0 (map-&gt;Plane {:plane-point (v/vec [1 0 0])\n                               :u-axis      (v/vec [0 1 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [0 1 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n        my-plane1 (map-&gt;Plane {:plane-point (v/vec [-1 0 0])\n                               :u-axis      (v/vec [0 0 1])\n                               :v-axis      (v/vec [0 1 0])\n                               :normal      (- (v/cross-product! (v/vec [0 0 1]) (v/vec [0 1 0])))\n                               :surface     plane-surface})\n\n        my-plane2 (map-&gt;Plane {:plane-point (v/vec [0 0 0])\n                               :u-axis      (v/vec [1 0 0])\n                               :v-axis      (v/vec [0 0 1])\n                               :normal      (- (v/cross-product! (v/vec [1 0 0]) (v/vec [0 0 1])))\n                               :surface     plane-surface})\n\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2 my-plane0 my-plane1 my-plane2]\n\n        ^BufferedImage im (new-image res-x res-y)]\n    (dotimes [ix res-x]\n      (dotimes [iy res-y]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera ix iy))]\n          (if-let [traced-ray (trace-ray ray scene-objects light-direction 2)]\n            (let [reflected-ray (:reflected-ray traced-ray)\n                  pixel-colour (:pixel-colour traced-ray)\n\n                  pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                  pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                  pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n\n              (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n              (.setRGB im ix iy (c/argb-from-vector4 colour-result)))))))\n    im))&quot; &quot;abs&quot; &quot;a&quot; &quot;1&quot; &quot;(time (image/show (render-spheres4) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(def res-x 200)&quot; &quot;(def res-y 200)&quot; &quot;(time (image/show (render-spheres) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-spheres3) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(time (image/show (render-spheres2) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(defn camera-ray [^Camera camera res-x res-y x y]\n  (let [camera-direction (:camera-direction camera)\n        camera-x (:camera-x camera)\n        camera-y (:camera-y camera)]\n    (v/normalise (+ (* 2 (- (/ (double x) res-x) 0.5) camera-x) (* -2 (- (/ (double y) res-y) 0.5) camera-y) camera-direction))))&quot; &quot;(defrecord Ray \&quot;Ray object. Has an origin and direction (both 3d vectors)\&quot; [ray-origin ray-direction])&quot; &quot;(defrecord Ray  [ray-origin ray-direction] \&quot;Ray object. Has an origin and direction (both 3d vectors)\&quot;)&quot; &quot;(time (image/show (render-3spheres 100 2) :title \&quot;Isn't it beautiful?\&quot;))&quot; &quot;(if nil)&quot; &quot;(= false nil)&quot; &quot;(= false false)&quot; &quot;(= false 0)&quot; &quot;(&lt; 0 0.5)&quot; &quot;(&lt; 0 nil)&quot; &quot;(= 0 nil)&quot; &quot;(defn render-3spheres \&quot;Example scene depicting 3 adjacent reflective spheres.\&quot; [resolution iterations]\n  (let [^BufferedImage im (new-image resolution resolution)\n        colour-result (v/vec4 [0 0 0 1])\n\n        ^Vector3 light-direction (v/normalise (v/vec3 [0 0 2]))\n        my-camera (map-&gt;Camera {:camera-location  ^Vector3 (v/vec3 [0 0.5 1])\n                                :camera-direction ^Vector3 (v/vec3 [0 0 1])\n                                :camera-x         ^Vector3 (v/vec3 [1 0 0])\n                                :camera-y         ^Vector3 (v/vec3 [0 1 0])})\n\n        sphere-surface0 (map-&gt;LambertPhong {:lambert-weight 0.8 :lambert-colour (v/vec [1 0 0])\n                                            :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                            :phong-exponent 50 :reflectivity 0.8})\n        sphere-surface1 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [1 0 1])\n                                            :phong-weigh    0.5 :phong-colour (v/vec [1 0 1])\n                                            :phong-exponent 5 :reflectivity 0.8})\n        sphere-surface2 (map-&gt;LambertPhong {:lambert-weight 0.5 :lambert-colour (v/vec [0 1 0])\n                                            :phong-weigh    0.2 :phong-colour (v/vec [0 1 1])\n                                            :phong-exponent 2 :reflectivity 0.8})\n\n        my-sphere0 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [1 0 3]) :radius 1 :surface sphere-surface0})\n        my-sphere1 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [0 (math/sqrt 3) 3]) :radius 1 :surface sphere-surface1})\n        my-sphere2 (map-&gt;Sphere {:center ^Vector3 (v/vec3 [-1 0 3]) :radius 1 :surface sphere-surface2})\n\n        plane-surface (map-&gt;LambertPhong {:lambert-weight 0.1 :lambert-colour (v/vec [1 1 1])\n                                          :phong-weigh    1 :phong-colour (v/vec [1 1 1])\n                                          :phong-exponent 5\n                                          :reflectivity   1})\n\n        scene-objects [my-sphere0 my-sphere1 my-sphere2]]   ;setup scene\n    (dotimes [ix resolution]\n      (dotimes [iy resolution]\n        (let [ray (Ray. (:camera-location my-camera) (camera-ray my-camera resolution resolution ix iy))]\n          (let [pixel-colour (:pixel-colour (trace-ray ray scene-objects light-direction iterations))\n                pixel-r (if pixel-colour (v/get pixel-colour 0) 0)\n                pixel-g (if pixel-colour (v/get pixel-colour 1) 0)\n                pixel-b (if pixel-colour (v/get pixel-colour 2) 0)]\n            (.setValues colour-result pixel-r pixel-g pixel-b 1.0)\n            (.setRGB im ix iy (c/argb-from-vector4 colour-result))))))\n    im))&quot; &quot;(#(* % %) 5)&quot; &quot;(defn recursive-printer\n  ([]\n    (recursive-printer 0))\n  ([iteration]\n    (println iteration)\n    (if (&gt; iteration 3)\n      (println \&quot;done\&quot;)\n      (recursive-printer (inc iteration)))))&quot; &quot;(recursive-printer)&quot; &quot;(defn recursive-printer\n  ([]\n    (recursive-printer 0))\n  ([iteration]\n    (println iteration)\n    (if (&gt; iteration 3)\n      (println \&quot;done\&quot;)\n      (recursive-printer (inc (inc iteration))))))&quot; &quot;(defn factorial [x]\n  (if (&lt; x 2)\n    1\n    (* x (factorial (- x 1)))\n    ))&quot; &quot;(factorial 2)&quot; &quot;(factorial 3)&quot; &quot;(factorial 5\n           )&quot; &quot;(factorial 1           )&quot; &quot;(factorial 10)&quot; &quot;(defn fibs\n  ([]\n    (fibs 0))\n  ([iteration]\n    (println iteration)\n    (if (&gt; iteration 3)\n      (println \&quot;done\&quot;)\n      (fibs (inc (inc iteration))))))&quot; &quot;(fibs 10)&quot; &quot;(fibs 0)&quot; &quot;(defn fibs\n  ([]\n    (fibs 0))\n  ([iteration]\n    (println iteration)\n    (if (&gt; iteration 3)\n      (println \&quot;done\&quot;)\n      (fibs (inc iteration)))))&quot; &quot;(defn fibs\n  ([]\n    (fibs 0))\n  ([i]\n    (println i)\n    (if (&gt; i 3)\n      (println \&quot;done\&quot;)\n      (fibs (* i (inc i))))))&quot; &quot;(loop [iteration 0]\n  (println (str \&quot;Iteration \&quot; iteration))\n  (if (&gt; iteration 3)\n    (println \&quot;Goodbye!\&quot;)\n    (recur (inc iteration))))&quot; &quot;(loop [iteration 0 tmp 0]\n  (println (str \&quot;Iteration \&quot; iteration))\n  (if (&gt; iteration 3)\n    (println \&quot;Goodbye!\&quot;)\n    (recur (inc iteration) 0)))&quot; &quot;(loop [i0 i1]\n  (println i0)\n  (if (&gt; i1 10)\n    (print \&quot;goodbye\&quot;)\n    (recur i1 (+ i0 i1))))&quot; &quot;(loop [i0 1 i1 1]\n  (println i0)\n  (if (&gt; i1 10)\n    (print \&quot;goodbye\&quot;)\n    (recur i1 (+ i0 i1))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (recur remaining (conj processed (inc (item))))))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (print item)\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(incr '(2 4 6))&quot; &quot;(incr 2 4 6)&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (print item \&quot;\\n\&quot;)\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if (empty? to-process)\n      processed\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        (print remaining item to-process \&quot;\\n\&quot;)\n        (recur remaining processed)\n        ;(recur remaining (conj processed (inc (item))))\n        ))))&quot; &quot;(2)&quot; &quot;(+ 1 1)&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if to-process\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        ; (print remaining item to-process \&quot;\\n\&quot;)\n        (recur remaining (conj processed 0))\n        ;(recur remaining (conj processed (inc (item))))\n        )\n      processed)))&quot; &quot;(defn incr [input-list]\n  (loop [to-process input-list\n         processed []]\n    (if to-process\n      (let [[item &amp; remaining] to-process\n            processed (conj processed item)]\n        ; (print remaining item to-process \&quot;\\n\&quot;)\n        (recur remaining (conj processed (inc item)))\n        ;(recur remaining (conj processed (inc (item))))\n        )\n      processed)))&quot; &quot;(incr [2 4 6])&quot; &quot;(print (incr [2 4 6]))&quot; &quot;(defn better-symmetrize-body-parts\n  \&quot;Expects a seq of maps which have a :name and :size\&quot;\n  [to-process]\n  (reduce (fn [processed part]\n            (let [processed (conj processed part)]\n              processed))\n          []\n          to-process))&quot; &quot;(defn incr2\n  [to-process]\n  (reduce (fn [processed part]\n            (let [processed (conj processed part)]\n              processed))\n          []\n          to-process))&quot; &quot;(print (incr2[2 4 6]))&quot; &quot;(defn incr2\n  [to-process]\n  (reduce (fn [processed part]\n            (let [processed (conj processed part)]\n              (conj processed (inc part))))\n          []\n          to-process))&quot; &quot;(defn incr2\n  [to-process]\n  (reduce (fn [processed part]\n            (print processed part \&quot;\\n\&quot;)\n            (let [processed (conj processed part)]\n              (conj processed (inc part))))\n          []\n          to-process))&quot; &quot;(defn incr2 [to-process]\n  (reduce (fn [processed part]\n            (print processed part \&quot;\\n\&quot;)\n            (let [processed (conj processed part)]\n              (conj processed (inc part))))\n          []\n          to-process))&quot; &quot;(print (incr2 [2 4 6]))&quot;], :remote []}}</component>
</project>

